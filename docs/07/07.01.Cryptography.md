---
lang: zh-CN
title: Section 7.1 Cryptography
description: some description
---

As you study this section, answer the following questions:

<ul>
    <li>
     What is the difference between symmetric and asymmetric encryption?
    </li>
    <li>
     Which algorithms can be used to generate a hash?
    </li>
    <li>
     What does a digital signature provide?
    </li>
    <li>
     What is a legitimate use for steganography?
    </li>
    <li>
     What are uses of blockchain in addition to cryptocurrency?
    </li>
    <li>
     What type of attack uses a large list of common words and phrases?
    </li>
   </ul>

In this section, you will learn to:

<ul>
    <li>
     Crack a symmetric encryption key.
    </li>
    <li>
     Use steganography to hide a file.
    </li>
   </ul>

Key terms for this section include the following:

<table class="terms">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Term
    </th>
    <th scope="col" class="fw-bold">
     Definition
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Cryptography
    </td>
    <td>
     The science and study of concealing information.
    </td>
   </tr>
   <tr>
    <td>
     Cipher/algorithm
    </td>
    <td>
     The process or formula used to encrypt a message or otherwise hide the message's meaning.
    </td>
   </tr>
   <tr>
    <td>
     Encryption key
    </td>
    <td>
     A string of bits randomly generated using a specific cipher. An encryption key is used to encrypt or decrypt data.
    </td>
   </tr>
   <tr>
    <td>
     Plaintext
    </td>
    <td>
     The readable form of a message.
    </td>
   </tr>
   <tr>
    <td>
     Ciphertext
    </td>
    <td>
     The encrypted form of a message that is readable only by those for whom the message is intended.
    </td>
   </tr>
   <tr>
    <td>
     Encryption
    </td>
    <td>
     The process of using an algorithm or cipher to transform data from cleartext to ciphertext in order to
        protect the confidentiality, integrity, and authenticity of the message.
    </td>
   </tr>
   <tr>
    <td>
     Decryption
    </td>
    <td>
     The process of converting data from ciphertext into plaintext.
    </td>
   </tr>
   <tr>
    <td>
     Steganography
    </td>
    <td>
     The practice of concealing a
        file, message, image, or video within another file, message, image, or video.
    </td>
   </tr>
   <tr>
    <td>
     Blockchain
    </td>
    <td>
     A decentralized and distributed ledger of transactions between two or more parties. Blockchain uses cryptography to keep sensitive data secure.
    </td>
   </tr>
  </tbody></table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Exam
    </th>
    <th scope="col" class="fw-bold">
     Objective
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     TestOut Security Pro
    </td>
    <td>
     4.0 Data Security
     <blockquote>
      4.2 Implement Encryption Technologies
     </blockquote>
    </td>
   </tr>
   <tr>
    <td>
     CompTIA Security+ SY0-601
    </td>
    <td>
     2.8 Summarize the basics of cryptographic concepts
    </td>
   </tr>
  </tbody></table>

## 7.1.1 Cryptography Concepts

### Cryptography Concepts 00:00-00:32

A security specialist's main goal is to keep data safe and out of the hands of hackers and other threats. To do that, you can lock down a system using multiple methods, but there's always a chance that a hacker will still get through. You can use cryptography to add an additional layer of protection and make it even more difficult for hackers to steal your data, even if they get inside.

In this video, we'll discuss what cryptography is, the basic concepts associated with cryptology, and some common cryptology methods.

Cryptography is defined as the process of writing or solving messages using a secret code.

### Cryptography Overview 00:32-01:41

Cryptography isn't new. The earliest known use of cryptography was by the Egyptians in 1900 BC to deliver messages using encryption.

Encryption is the process of converting normal text into text that makes no sense at all, which is called ciphertext. A cipher is the method, or algorithm, used to encrypt the data. I know that might sound a little confusing, since these terms are often used interchangeably, so let's look at an example using a puzzle.

When you're completing a puzzle, you normally look at the completed picture on the box and then put the pieces together to match the picture. If you wanted to disguise the puzzle from prying eyes, you could use cryptography. In this case, you could encrypt the puzzle by flipping all the pieces over and scrambling them up, so no one can see the images printed on the puzzle pieces. Then, to allow you or anyone else to put the puzzle together, you'll need a method that's only given out to certain people. That's the cipher. We'll used a numbered cipher here. Using that cipher, anyone would be able to put the puzzle together.

### Caesar Cipher 01:41-02:07

One of the most common encryption ciphers is the Caesar cipher.

This cipher was created by Julius Caesar. When he wanted to sent a secret message, Caesar would shift each letter down the alphabet by three places. Then he could safely send the message to his commanders because anyone who intercepted the message couldn't read it anyway. Since only the commanders knew the cipher was to shift the letters up the alphabet by three, only they could read it.

### Cryptography Concepts 02:07-02:19

Today, encryption is much more advanced than the Caesar cipher. You'll hear a lot about encryption keys, hashes, and digital signatures. To understand modern encryption, you need to understand these concepts.

### Encryption Keys 02:19-03:05

Let's talk about encryption keys first. We install locks on our doors to keep our homes safe. These locks require a specific key. Encryption works using the same concept. When we want to encrypt data, we use an encryption key. Encryption keys are random strings of bits that are used to lock and unlock data. These keys are generated using ciphers, such as the Advanced Encryption Standard, or AES. They ensure each key is unique and difficult to crack.

There are two types of encryption methods, symmetric and asymmetric. Symmetric encryption uses the same key to encrypt and decrypt data. Asymmetric encryption uses one key to encrypt and then a different key to decrypt. These are referred to as public and private keys.

### Hashing 03:05-03:49

When you're working with these encryption methods, different techniques are used to help safeguard your data. One technique is known as hashing.

Hashing is the process of converting one value into another using a mathematical algorithm like MD5 or SHA. Hashes have several characteristics that make them very useful. For example, hashes are deterministic, meaning that the same data being hashed always results in the same hash value. Hashes can also be created very quickly and cannot be decrypted. Likewise, it's infeasible to find two messages with the same hash value. Even a small change to a message will change the hash value so extensively that the new hash value appears uncorrelated with the old hash value.

### Hash Applications 03:49-04:11

Because of these features, hashes are used in many applications.

A hash function is often used to verify passwords. Since storing or transmitting passwords in cleartext could result in a massive security breach, most systems only store the hash of the password. When a user needs to be authenticated, the password entered by the user is hashed and compared with the stored hash.

### Salting the Hash 04:11-05:31

One of the problems with using hashed passwords is that several online sites have collected massive databases containing a hash for tens of million of possible passwords. Once a hash has been captured, it can be compared with the hashes found in the database, quickly resulting in the password used to create the hash. To keep this from happening, most hashes also incorporate something called a salt.

Salting the hash means adding a random number of characters to the password before the hash is created. For example, if this is the password to be hashed, a salt such as this may be added. This becomes the string to be hashed. Since the salt is randomly generated each time, even if the same password is used and can be varying lengths, it's virtually impossible to create a database containing all the possible salted passwords.

Hashes are also used to verify that a document hasn't been corrupted or tampered with by creating a hash for the document. When the same hash algorithm is calculated at the receiving end, the hashes should match. If not, then the data was either corrupted or tampered with during transmission and should not be trusted. In a similar fashion, hashes are also used to digitally verify a signature, like when you digitally sign an important document using the internet. In this case, only the signature is hashed instead of the entire document.

### Cryptology Methods 05:31-06:04

While there are many different cryptography methods that can be used to secure data, one of the most powerful methods used today is Elliptic Curve Cryptology, or ECC. Many websites use this method to secure connections and the data they send back and forth.

To truly understand ECC and how it works would require us to dive into some really complicated math that's beyond the scope of this lesson. For now, you just need to know that this method is the next generation of cryptology, and the algorithm used can generate smaller keys that are more secure than other cryptology methods.

### Steganography 06:04-06:39

The last encryption technique we'll discuss is call steganography. Steganography is the technique of hiding or concealing a file, message, image, or video within another file, message, image, or video. If you've ever used invisible ink to write a hidden message, you've used steganography.

One method of steganography is to use a special program to hide a message in another file, such as this image. When the recipient receives the image, they can use the same software to find the hidden message. If the file is intercepted by a hacker, all they'll see is the image.

### Summary 06:39-07:03

That's it for this lesson. In this lesson, we discussed what cryptography is and how encryption and ciphers are used. We covered the key concepts of cryptography, including encryption keys, hashes, and digital signatures.

And then we looked at a few cryptology methods, including hashing, elliptical curve cryptology, and steganography.

## 7.1.2 Cryptography Facts

The goal of all IT security specialists is to keep data safe. Hackers find ways to circumvent firewalls, IPS devices, and other security protocol put in place. Cryptography is one additional layer of defense that can be used to protect data.

This lesson covers the following topics:

- Cryptography overview
- Cryptography concepts
- Cryptography methods

### Cryptography Overview

Cryptography is defined as the process of writing or solving messages using a secret code. A form of cryptography called encryption has been used throughout the ages, mainly to keep messages out of the hands of enemies. Encryption is the process of converting normal readable text into something that is unintelligible called ciphertext. A cipher is the method, or algorithm, used to encrypt or convert the data.

One of the more popular forms of encryption is the Caesar cipher. This encryption method works by shifting each letter in the alphabet a certain number of spaces to the right or left. In the example below, the cipher is shifting to the right by three letters. A becomes D, B becomes E, C becomes F, and so forth.

![Caesar cipher example](/images/07/shift_example.jpg)

To decrypt the message, the reader must know how many spaces to shift the letters. For example, to encrypt the word TESTOUT using the Caesar Cipher with a shift of 3 to the right, TESTOUT would become WHVWRXW.

Below is the complete Caesar cipher using a shift of three letters to the right (you can see below which letters are used when they are shifted 3 spaces):

![Alphabet shifted by 3](/images/07/caesar_cipher.jpg)

This is a very simple example of cryptography and is easily decrypted. With today's computing power, encryption methods used are much more complicated and powerful.

### Cryptography Concepts

There are three main concepts to understand when dealing with today's encryption methods: encryption keys, hashing, and digital signatures.

<table>
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Cryptography Concept
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody>
    <tr>
     <td>
      Encryption keys
     </td>
     <td>
      Encryption keys are used to encrypt and decrypt
            data. The key is a string of bits that is randomly generated using a
            specific cipher, such as Advanced Encryption Standard (AES). There
            are two types of encryption methods used with keys: symmetric and
            asymmetric.
      <br>
      <ul>
       <li>
        Symmetric encryption uses the same key to encrypt and decrypt
                data.
       </li>
       <li>
        Asymmetric encryption uses one key to encrypt the data and a
                different key to decrypt the data. These keys are known as a
                public key and private key.
       </li>
      </ul>
     </td>
    </tr>
    <tr>
     <td>
      Hashing
     </td>
     <td>
      Hashing is the process of converting one value
            into another using a mathematical algorithm like MD5 or SHA. This
            fixed length of data is called the hash.
      <ul>
       <li>
        Hashing is used on data that does not need to be decrypted,
                such as a password.
       </li>
       <li>
        When a piece of data is run through a hashing algorithm, it
                always generates the same hash. If even one letter in a file has
                been altered, the resulting hash would be different. Because of
                this, hashing can be used to verify that data has not been
                altered during transmission.
       </li>
       <li>
        A hash cannot be decrypted. However, when using hashing for
                passwords, many online sites have collected massive databases
                containing a hash for tens of millions (or more) of possible
                passwords. Once a hash has been captured, it can be compared
                with the hashes found in the database, quickly resulting in the
                password used to create the hash.
       </li>
      </ul>
     </td>
    </tr>
    <tr>
     <td>
      Salt
     </td>
     <td>
      Salt, or salting the hash, means that a random
            number of characters are added to the password before the hash is
            created.
      <p>
       For example, if the password to be hashed was p@ssw0rd, a salt,
              such as E1343135E119C253, may be added. Therefore, the string to
              be hashed would be p@ssw0rdE1343135E119C253. Since the salt is
              randomly generated each time, even if the same password is used
              and is of varying lengths, it’s virtually impossible to create a
              database containing all the possible salted passwords.
      </p>
     </td>
    </tr>
    <tr>
     <td>
      Digital signatures
     </td>
     <td>
      By combining a user's private encryption key and a
            hash of the data, a user can create a digital signature. A digital
            signature verifies that the data is legitimate and provides
            non-repudiation. This means that the sender cannot deny having sent
            the file.
     </td>
    </tr>
   </tbody>
  </table>

### Cryptography Methods

There are many different cryptography methods used today. One important thing to keep in mind is that all cryptography uses advanced math concepts to generate encryption keys and hashes.

<table>
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Cryptography Method
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody>
    <tr>
     <td>
      Elliptic Curve Cryptography (ECC)
     </td>
     <td>
      Elliptic Curve Cryptography is one of the newer
            methods being implemented. ECC is able to generate smaller keys that
            are more secure than most other methods. Many websites today use ECC
            to secure connections and data transmissions.
     </td>
    </tr>
    <tr>
     <td>
      Perfect Forward Secrecy
     </td>
     <td>
      This cryptography method is used quite often in
            messaging apps. Instead of the same key being used for an entire
            conversation or session on a website, each transmission is encrypted
            with a different unique key.
     </td>
    </tr>
    <tr>
     <td>
      Steganography
     </td>
     <td>
      Steganography is the technique of hiding or
            concealing a file, message, image, or video within another file,
            message, image, or video. Special programs are often used to hide
            messages in media files. If a hacker intercepts the message, all
            they see is the media. They don't know that there is a hidden
            message.
     </td>
    </tr>
   </tbody>
  </table>

## 7.1.3 Symmetric vs Asymmetric Encryption

### Symmetric vs. Asymmetric Encryption 00:00-00:37

Keeping data and messages safe from prying eyes is the goal of cybersecurity. We can hide data from hackers by encrypting it. Encryption is the process of encoding data into a format that's unreadable. All encryption relies on a unique key to encrypt and decrypt the data. This key is basically a password that's combined with the cipher to encrypt the data. In this lesson, we're going to look at some encryption methods including symmetric encryption, asymmetric encryption, hybrid cryptosystems, and ephemeral keys.

### Symmetric Encryption 00:37-01:55

Symmetric encryption uses the same key to encrypt and decrypt data. This is the simplest and oldest form of encryption. Let's look at how this works.

Travis has a confidential file that he needs to send to Craig. To ensure that the file is sent safely, Travis encrypts the file using his secret symmetric encryption key and sends it to Craig. To open the file, Craig must use the same encryption key to decrypt the file.

One of the biggest problems with symmetric encryption is that both parties must use the same key. If Travis and Craig send encrypted data often, they've probably set up this secret key in advance. But if not, Travis needs to let Craig know what the secret key is. Sending the key with the data defeats the purpose because if a hacker intercepts the message, they can decrypt the file.

Imagine what a pain it would be to distribute the secret key if multiple people were to need access to it. Not only is this difficult to do, but the more people that have the key, the more likely it is for the key to be compromised.

Symmetric encryption is very secure and works extremely well when you need to encrypt a large amount of data because it requires less CPU power than asymmetric encryption.

### Symmetric-Key Algorithms 01:55-02:06

There are many symmetric-key algorithms used, but some of the more common ones are Data Encryption Standard,

Rivest Cipher, and Advanced Encryption Standard.

### Data Encryption Standard (DES) 02:06-02:49

The Data Encryption Standard, or DES, cipher was originally developed by IBM in the early 1970s and used heavily throughout the years. But due in part to its short key length of only 56 bits, hackers in the 1990s were able to brute-force the encryption keys. In other words, they were able to try every possible key until they found the right one. In 1998, an attempt to further secure DES was introduced. It was known as the Triple Data Encryption Algorithm, or 3DES. 3DES combined 3 keys to give it a key length of 168 bits, making it much more difficult to brute-force. Unfortunately, 3DES requires more CPU power and isn't used as much these days.

### Rivest Cipher (RC) 02:49-03:08

The Rivest Cipher, or RC, family of algorithms were developed by Ron Rivest in 1987. RC4 was once the most widely used cipher but is no longer supported as multiple vulnerabilities have been discovered. The latest version, RC6, is a 128-bit cipher.

### Advanced Encryption Standard (AES) 03:08-03:40

The Advanced Encryption Standard, or AES, has for the most part replaced all other types of symmetric encryption. AES is a subset of the Rijndael block cipher, developed by Vincent Rijmen and Jaon Daemen. It was developed in 2001 during a competition run by the US National Institute of Standards and Technology, or NIST. AES offers three key lengths of 128, 192, or 256 bits. AES is used in all sorts of ways including 802.11 communication, BitLocker, and even some games engines.

### Other Symmetric Algorithms 03:40-03:53

Some other symmetric algorithms you may come across are Blowfish, IDEA, CAST, and Twofish. While these algorithms aren't used much anymore, you should at least know they exist.

### Asymmetric Encryption 03:53-05:23

Asymmetric encryption makes use of two different keys, a public key and a private key. The public key is used to encrypt the data and the private key is used to decrypt it. Since these keys mirror each other, the private key only decrypts data that was encrypted with the matching public key. Let's see this in action.

Travis is sending his confidential file to Craig. To do that, Travis must first get Craig's public key. Travis then uses Craig's public key to encrypt the data, and the file is sent to Craig. When Craig gets the file, he uses his private key to decrypt it. As another example, asymmetric encryption is used in most communication over the internet.

For example, when you log on to a website, your browser sends a request for the public key which is then sent by the web server. Your login information is entered and encrypted using that public key, which is then sent to the server. The server in turn decrypts the login information using its private key. You're now logged into the web server. As you can see from these examples, users don't ever reveal their private keys in this exchange. Data security is increased with asymmetric encryption, which is the primary reason for using it.

Another reason for using asymmetric encryption is to create digital signatures.

A digital signature is a method used to ensure that a received message or document hasn't been modified from the time it was signed.

### Digital Signatures 05:23-06:04

This is done by generating a unique hash of the message or document and encrypting it with the sender's private key. When the recipient receives the message, they can verify the digital signature to ensure that the data or message is legitimate. Since anyone can decrypt these messages or documents with the public key, digital certificates don't secure data. They simply verify that the data is legitimate and came from the proper source. Guaranteeing the data source in this way provides non-repudiation, or the ability to ensure that the document's sender cannot deny sending the document.

There are four main asymmetric encryption algorithms you need to be aware of. These are Diffie-Hellman, RSA, DSA, and ECC.

### Diffie-Hellman 06:04-07:15

Diffie-Hellman was the first widely used asymmetric algorithm. It was released in 1976 by Whitfield Diffie and Martin Hellman. This algorithm allows two parties who've never met to safely create a shared key over a public channel, such as the internet. We can see how this key is created using a choice of colors.

For example, our two users each agree on a paint color such as yellow. Each user then decides on a secret color to mix with their common color, creating a color they can share publicly. They send each other their results and then mix in their secret color. Each user ends up with the same new secret color. This new secret color, or key, is then used to encrypt and decrypt their messages. If a hacker were to intercept any of these messages without knowing each user's secret color, they wouldn't be able to reverse the process and figure out the final secret color. Diffie-Hellman is frequently implemented in security protocols such as TLS, IPSec, SSH, and more.

### Rivest-Shamir-Adleman (RSA) 07:15-07:43

In 1977, Ron Rivest, Adi Shamir, and Leonard Adleman released one of the first public-key cryptosystems, which is known by the initial letters of the developer's surnames—"RSA. RSA defined the process of using a public key to encrypt data and a secret key to decrypt it. RSA is still one of the most widely used algorithms for securing data transmissions and creating digital signatures.

### Digital Signature Algorithm (DSA) 07:43-08:01

The Digital Signature Algorithm, or DSA, is a Federal Information Processing Standard for digital signatures. It was proposed in 1991 by NIST and became the government standard in 1993. It uses a different algorithm than RSA but provides the same level of security.

### Elliptic Curve Cryptography (ECC) 08:01-08:19

Elliptic Curve Cryptography, or ECC, is the latest encryption method. The algorithms used with this method can generate smaller keys that are just as secure as other methods. Many websites have adopted ECC to secure data being sent back and forth.

### Hybrid Cryptosystems 08:19-09:24

Asymmetric encryption methods aren't very efficient because they rely on some complicated mathematical computations. But they do make it easier to exchange keys. In contrast, Symmetric methods are efficient, but they become inconvenient when the time comes to get the keys out. A hybrid cryptosystem combines the efficiency of symmetric methods and the convenience of asymmetric methods.

Let's see how it works.

Travis needs to send a confidential file to Craig. Before doing so, Travis uses his symmetric private key to encrypt the data. Next, Travis encrypts the secret key using Craig's public key. The file is then sent to Craig. When Craig gets the message, he first uses his private key to decrypt the symmetric secret key and then uses the symmetric key to decrypt the message.

As long as Craig's private key is kept secret, the data is secure. Most secure communication methods such as TLS utilize a hybrid cryptosystem nowadays.

### Ephemeral Keys 09:24-10:12

Generally, when we establish a session and exchange keys, all communication during that session uses the same encryption keys. These are known as static keys. The problem is that the longer a key is used, the more susceptible it is to attack. To combat this, we use ephemeral keys.

These are keys that are generated for each new session or transaction. Perfect forward secrecy makes use of ephemeral keys. Perfect forward secrecy and ephemeral keys are used quite often in instant messaging apps.

Every message that's sent generates its own encryption key. It doesn't matter if a hacker intercepts any of the keys because the next message has a completely different one. The hacker is unable to eavesdrop on the entire conversation or session.

### Summary 10:12-10:47

That's it for this lesson. In this lesson, we first looked at symmetric encryption which uses the same key to encrypt and decrypt data. We then looked at asymmetric encryption which uses a public key and a private key to encrypt and decrypt data. We also covered hybrid cryptosystems that combine the efficiency of symmetric methods and the convenience of asymmetric methods. Finally, we covered ephemeral keys. These are keys that are generated for each new session or transaction.

## 7.1.4 Cracking a Symmetric Encryption Key

### Cracking a Symmetric Encryption Key 00:00-00:15

In this demonstration we're going to look at how cryptography works. We'll also look at the steps required to perform crypto analysis to recover information without having an encryption key.

### CrypTool 00:15-00:55

The tool that we're going to use is called CrypTool and you can get it here at cryptool.org.

At the heart of modern cryptography algorithms is the idea that you have a key, either a symmetric or asymmetric key, to encrypt and decrypt information that you want to send privately across, say, the internet.

This tool has a number of different algorithms that we can use in order to encrypt sample documents. They have a sample document here on the screen for us that we can use.

To encrypt a document, I come up here to the encrypt/decrypt and I select modern algorithms. I'm going to select RC4 algorithm, and in this case we can specify the length of the key that we want to include.

### Short Keys vs. Long Keys 00:55-04:17

I want to show you that shorter keys are very easy to crack, longer keys take substantial amount of time if they're long enough.

So, here we're going to select an 8-bit key length and I'm going to specify my key. I'll just say AD and encrypt the document.

So, now we have the encrypted document and to decrypt it, if we already knew the key we could just come to this encrypt/decrypt option again, but since we want to discover what the key is, we'll come over here to analysis and come down to symmetric encryption and select the RC4 algorithm.

We'll go ahead and click start and it's already done. It's found possible key values and you can see the possible decrypted values up here. And of course this looks like something that we would expect and it says, hey, the key was AD. Go ahead and select that and it goes ahead and decrypts the document for us.

So, that was very, very quick. It didn't take any time at all. Let's go ahead and increase our key length and see what happens. So, we'll come down to RC4 and try instead a 16-bit key length. And we'll put in some numbers. And we'll encrypt.

And then we'll come over to analysis and do the same thing. Say 16-bit key length and start our analysis. And again, almost immediately, it comes back.

Let's go ahead and cancel out of that and let's increase our key length over here and see some that start taking a little bit of time.

Now, of course as processors get faster, you can do these things a lot easier. And in this case, it'll take just a couple seconds, but as we get to bigger, bigger key, it'll take substantially longer.

Comparing an RC4 24-bit, we're up to 10%. On my system, which is actually kind of beefy, looks like it's going to take about 30 seconds or so to complete. Let's go ahead and wait for that.

Okay, now that it's done it shows us the possible decryption values and sure enough, the key that it discovered for us does decrypt and shows the original document.

Let's go ahead and just show one more. Let's come up and instead of a 24-bit key, let's do a 32-bit key and put in some values. These are hex values of course. And then we'll come over and do our analysis.

In this case it looks like 32-bit on my machine will take about three hours to complete. Let's go ahead and just see what if we did a 56-bit key or higher.

Oops, we'll come back to the original document and I want to show you how this raises exponentially as you go on. So, let's do a 56-bit key, which is a reasonable length.

You wouldn't use that on the internet today, but in the early days, that was used and it was found to be too weak by brute force analysis, as you might see here.

So, let's go 56-bit. We'll go ahead and start. You can see we're in to a lot of years in order to brute force with a single computer. Now, of course we could cluster computers or use the cloud to decrypt these.

So many encryption algorithms are no longer considered secure, because you can do brute force analysis over many different computers. With enough computing power, you've got to be careful on the length of your key.

I hope this shows you that the length of the key matters. You always want a longer key if you want your data more secure.

### Summary 04:17-04:49

So, in this demonstration we explored the relationship between key length and the time it takes for a brute force attack to decrypt a document. And there are great free tools to help us with that.

This is CrypTool version one, there's also a version two, which is more of a wizard type that allows you to take input, run it through different algorithms and see what the result would be.

So, I encourage you to check out both CrypTool and CrypTool version two.

## 7.1.5 Symmetric and Asymmetric Encryption Facts

Encryption is the process of encoding data into something that is unreadable called ciphertext. All encryption processes rely on using a unique key. The encryption key is basically a password that is combined with the cipher to encrypt the data.

This lesson covers the following topics:

- Symmetric encryption
- Asymmetric encryption
- Hybrid cryptosystems
- Ephemeral keys

### Symmetric Encryption

Symmetric encryption uses the same key to encrypt and decrypt data. This is the simplest and oldest form of encryption.
One of the main drawbacks of symmetric encryption is that the key must be shared before a user can decrypt a message.
If the key needs to be shared with multiple people, the integrity of the key is compromised as it becomes easier for a hacker to steal the key.

Symmetric encryption is extremely secure when the key is kept safe. This form of encryption is useful when a large amount of data needs to be encrypted as the encryption process requires less CPU power than other encryption methods.

The table below shows some of the more common symmetric key algorithms in use.

<table>
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Symmetric Algorithm
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Data Encryption Standard
     <br>
     (DES)
    </td>
    <td>
     The DES family of ciphers was first developed in the early 1970s by IBM.
     <ul>
      <li>
       DES was heavily used through the 1990s until hackers figured out how to brute-force the keys.
      </li>
      <li>
       Triple-DES (3DES) was introduced in 1998. This version combined 3 different keys, giving it a key length of 168
          bits.
      </li>
      <li>
       3DES is extremely CPU heavy and is not used much today.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Rivest's Cipher
     <br>
     (RC)
    </td>
    <td>
     The RC family of algorithms were developed by Ron Rivest in 1987.
     <ul>
      <li>
       RC4 was once the most used cipher. However, many vulnerabilities have since been found and it is no longer
          supported.
      </li>
      <li>
       RC6 is the latest version and is a 128-bit cipher.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Advanced Encryption Standard
     <br>
     (AES)
    </td>
    <td>
     AES, also known as the Rijndael cipher, was developed by Jaon Daemen and Vincent Rijmen in 2001 as part
        of a NIST competition held to find a replacement for DES.
     <ul>
      <li>
       AES has essentially replaced all other types of symmetric encryption.
      </li>
      <li>
       AES offers three different key lengths of 128, 192, and 256 bits.
      </li>
      <li>
       AES is used in many different applications including 802.11 communications, Bitlocker, and even game engines.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     International Data Encryption Algorithm
     <br>
     (IDEA)
    </td>
    <td>
     IDEA was first developed in 1991 by James Massey and Xuejia Lai.
     <ul>
      <li>
       IDEA was used in Pretty Good Privacy (PGP) 2.0 and is an optional algorithm in the OpenPGP standard.
      </li>
      <li>
       IDEA uses a 128-bit key.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Blowfish
    </td>
    <td>
     Blowfish was developed in 1993 by Bruce Schneier. It was meant to be a replacement for DES.
     <ul>
      <li>
       Blowfish is unpatented so that it can be used freely by anyone.
      </li>
      <li>
       Blowfish uses a 128-bit key.
      </li>
      <li>
       Vulnerabilities have been discovered in the Blowfish cipher and it is recommended to use its successor, Twofish,
          instead.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Twofish
    </td>
    <td>
     Twofish was one of the five finalists for the AES contest but ultimately was not chosen.
     <ul>
      <li>
       Twofish uses keys up to 256 bits in size.
      </li>
      <li>
       Twofish is slower than AES.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     CAST
    </td>
    <td>
     CAST is a family of ciphers that now consists of CAST-128 (CAST5) and CAST-256 (CAST6).
     <ul>
      <li>
       CAST5 is the most widely used CAST cipher. It replaced IDEA in PGP 3.0 and is also an option in all versions of Open
          PGP.
      </li>
      <li>
       CAST6 was entered in the AES competition but was not a finalist.
      </li>
     </ul>
    </td>
   </tr>
  </tbody></table>

### Asymmetric Encryption

Asymmetric encryption uses two keys instead of one. A user's public key is used to encrypt the data. That user then uses their private key to decrypt the data. The private key only decrypts data that was encrypted using its matching public key.

Asymmetric encryption is used in most communication over the internet. The following is an example of how asymmetric encryption is used:

<ol>
   <li>
    When a user wants to log into a website, the browser sends a request to the web server for the public key.
   </li>
   <li>
    The user's login information is encrypted using the public key and sent to the server.
   </li>
   <li>
    The server uses its private key to decrypt the user's login information.
   </li>
  </ol>

Asymmetric encryption is also used to create digital signatures.

<ul>
   <li>
    By using a private key along with a hash of the data being sent, a digital signature is created.
   </li>
   <li>
    The recipient can verify the digital signature to ensure the message is legitimate and actually comes from the
      sender.
   </li>
   <li>
    Digital signatures are not meant to encrypt or secure data. Their main function is to provide non-repudiation, which
      means the sender cannot deny having sent the message. Digital signatures are also used to verify that the data transmitted
      was not changed or corrupted.
   </li>
  </ul>

The following table shows the four main asymmetric encryption algorithms:

<table>
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Asymmetric Algorithm
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Diffie-Hellman
    </td>
    <td>
     Released in 1976 by Whitfield Diffie and Martin Hellman. Its purpose was to allow two users who have
        never met to safely create a shared key over a public channel such as the internet.
     <ul>
      <li>
       Diffie-Hellman is used as follows:
       <ol>
        <li>
         The two users agree on two numbers, a prime number (P) and a generator (g). These numbers can be shared
            publicly.
        </li>
        <li>
         Each user then randomly generates a private number, or key, unique to themselves.
        </li>
        <li>
         Using the prime number, generator, and private key, each user generates a public key using the following formula:
         <ul>
          <li>
           (G^
           <sup>
            private number
           </sup>
           ) MOD P
          </li>
         </ul>
        </li>
        <li>
         The users exchange their public keys which are then used to create a shared secret key using the following formula:
         <ul>
          <li>
           (Shared Public Key^
           <sup>
            private number
           </sup>
           ) MOD P
          </li>
         </ul>
        </li>
        <li>
         Because each public key was generated using the same prime number and generator, each user will come up with the
            same number for the shared secret key.
        </li>
        <li>
         If a hacker intercepted any of the exchanges, they wouldn't be able to reverse the process without knowing each
            user's secret number.
        </li>
       </ol>
      </li>
      <li>
       Diffie-Hellman is frequently implemented in security protocols such as TLS, IPSec, SSH, and others.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Rivest-Shamir-Adleman
     <br>
     (RSA)
    </td>
    <td>
     RSA was developed by Ron Rivest, Adi Shamir, and Leonard Adleman. RSA was released shortly after
        Diffie-Hellman in 1977.
     <ul>
      <li>
       RSA is still one of the most commonly used algorithms and helped defined the process of using a public key to encrypt
          data and a private key to decrypt the data.
      </li>
      <li>
       RSA is used extensively for creating digital signatures.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Digital Signature Algorithm (DSA)
    </td>
    <td>
     DSA was proposed in 1991 by NIST and became the government standard in 1993
     <ul>
      <li>
       DSA is only used for creating digital signatures.
      </li>
      <li>
       It uses a different algorithm than RSA but provides the same level of security.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Elliptic Curve Cryptography (ECC)
    </td>
    <td>
     Elliptic Curve Cryptology is one of the newer methods being implemented. It was originally introduced
        in 1985. It did not enter wide usage until 2004.
     <ul>
      <li>
       ECC is able to generate smaller keys that are more secure than most other methods.
      </li>
      <li>
       Many websites today use ECC to secure connections and data transmissions.
      </li>
     </ul>
    </td>
   </tr>
  </tbody></table>

### Hybrid Cryptosystems

Hybrid cryptosystems combine the efficiency of symmetric encryption with the convenience of asymmetric encryption. A hybrid cryptosystem is used as follows:

<ol>
   <li>
    User1 uses their symmetric private key to encrypt some data.
   </li>
   <li>
    User1 then encrypts that symmetric private key using the recipient's public key and sends both to the recipient.
   </li>
   <li>
    User2, the recipient, uses their private key to decrypt User 1's private key which is then used to decrypt the
      message.
   </li>
   <li>
    As long as User2's private key is kept secret, the data remains secure.
   </li>
  </ol>

Hybrid cryptosystems are used with many secure communication methods today such as TLS.

### Ephemeral Keys

In traditional encrypted communications, static keys are used. This means that the same key is used throughout an entire session. The problem with this is that the longer the keys are used, the more susceptible they become to an attack. Ephemeral keys can be used to resolve this issue.

Ephemeral keys are keys that are generated for each new session or message sent. For example, perfect forward secrecy (PFC) uses ephemeral keys.

Some popular instant messaging apps make use of ephemeral keys to encrypt messages. Each message sent uses a unique key to encrypt it. If a hacker intercepts one key, the rest of the messages are still safe.

## 7.1.6 Cryptography Algorithm

### Cryptography Algorithms 00:00-00:23

In this lesson, we're going to take a deeper dive into the world of cryptography. The cornerstone of cryptography is the algorithm, or cipher. Cipher is just a fancy word for the series of steps that are taken for data to be encrypted or decrypted. In this video, we're going to look at several types of ciphers and how they work.

### Stream Cipher 00:23-00:46

One of the first cipher types is the stream cipher. A stream cipher is a symmetric encryption method that encrypts 1 bit of plaintext at a time. This method is based on the one-time pad, or OTP, which was very popular during World War 2. OTP uses a symmetric encryption key that should be as long or even longer than the data being encrypted.

### One-Time Pad 00:46-02:06

For example, if you had a small message that was only 15 bits long, a random 15-bit key would need to be generated. That key can then be used to encrypt your message using a process called Exclusive-ORing, or XORing. XORing means that we compare two strings, our message and our random key, to generate an output. We do this by lining them both up. If the bits match, a 0 is generated. If they don't match, a 1 is generated. The output is our ciphertext!

What makes this so interesting is that this demonstrates perfect secrecy. This means that, to a hacker, this ciphertext looks completely random. It would be just as difficult to brute-force the key as it would be to brute-force the data itself.

OTP only works properly if our secret key is only used once. If we use it more than once, a hacker could then start to decode the secret key. OTP works great if we're dealing with small messages. But what if we needed to encrypt every video in this course?

A video can range from 500 megabytes to up to 5 gigs or more. Since every video file would need to generate a key that's the same size or larger than the video, we would quickly end up running out of hard drive space. So with today's data types, the one-time pad just isn't very practical.

### Stream Ciphers 02:06-02:53

Stream ciphers offer a solution to this problem.

A stream cipher can use a smaller fixed-length key that can be used repeatedly throughout the encryption process. This key is called a seed key, and in our example we'll say that it's 2048 bits. This key is run through a pseudorandom number generator which outputs a new and unique encryption key called a keystream. Notice that this new key matches the size of our data. The keystream is then XORed with the data to give us our ciphertext.

While stream ciphers are less secure than the one-time pad, the advantage to this method is that it can be used in real time. One of the most widely used stream ciphers was RC4. But due to multiple vulnerabilities discovered, it's no longer in use.

### Block Ciphers 02:53-03:45

Many symmetric encryption algorithms use the block cipher method. With block ciphers, instead of encrypting our data one bit at a time, the data is encrypted one chunk or block at a time. The common block sizes used are 64, 128, or 256 bits in length.

For example, let's say that we want to encrypt a file that's 800 bits in size. Using a 256-bit block size, the data will be encrypted 256 bits, or 32 bytes, at a time until the process is complete. Since the last block ends up being smaller than 256 bits, the algorithm pads the block with some random data to bring it up to 256 bits.

As shown here, there are several block cipher operation modes that can be utilized depending on the application or use. Let's talk about a few of them.

### Electronic Code Book (ECB) 03:45-04:12

Electronic Code Book Mode, or ECB, is the simplest block cipher operation mode.

With this mode, each block of plaintext data is encrypted separately. Several blocks can be encrypted at the same time, allowing for faster encryption. The biggest disadvantage is that identical data results in the same ciphertext, meaning that a hacker would be able to decipher some of the data if they intercept multiple blocks.

### Cipher Block Chaining (CBC) 04:12-04:41

Cipher Block Chaining is like ECB, except that it uses an initialization vector. The initialization vector is a starting variable that's XORed with the current block's plaintext to encrypt the data. The first initialization vector is a random string and each subsequent initialization vector is the ciphertext from the previous block. CBC is more secure than ECB but slower because multiple blocks can't be encrypted at the same time.

### Cipher Feedback Mode (CFB) 04:41-05:01

Cipher Feedback Mode, or CFB, also utilizes an initialization vector. But instead of using it on the plaintext, the initialization vector is encrypted and then that result is XORed with the plaintext to create the ciphertext block. This is the equivalent of encrypting the plaintext with a one-time pad.

### Output Feedback Mode (OFB) 05:01-05:30

Output Feedback Mode, or OFB, is practically identical to Cipher Feedback Mode. The difference is the initialization vector used after the first round of encryption. The CFB's output is XORed with the plaintext and the result is the next block's initialization vector. The process is the same in Output Feedback Mode, except that the encryption's output is the next block's initialization vector before it's XORed with the plaintext.

### Counter Mode 05:30-06:08

Next we have Counter Mode. Similar to ECB, every encryption process in Counter Mode is separate. Instead of using an initialization vector, Counter Mode uses a nonce combined with an encrypted counter. Nonce is simply a fancy word for a random string that's used for all blocks. The nonce's encrypted output and counter are then XORed with the plaintext to create the ciphertext. The counter starts at 0 and increments every block. By combining the nonce and counter, each block is using a different value so that even if the data is the same, the output will be different.

### Galois Counter Mode (GCM) 06:08-07:03

If we want to provide authentication with confidentiality, we can use the Galois Counter Mode, or GCM. This mode works just like Counter Mode. First, we have the counter and nonce encrypted. The output is XOR-ed with the plaintext to give us the ciphertext. Here's where things get different. The ciphertext is combined with a special hash. That output contains the ciphertext along with a message authentication code that gives us assurance that the data hasn't been tampered with. Because this method is efficient and provides authentication, we see it used often with network communications such as wireless networks and web servers that use SSH or TLS.

The other block cipher modes are classified as unauthenticated encryption and GCM is classified as authenticated encryption. There are some other encryption methods that authenticate, but the most common one is the Galois Counter Mode.

### Lightweight Cryptography 07:03-07:47

We're putting more and more Internet of Things, or IoT, devices into our networks; the need to encrypt data has never been more important. In 2018, the National Institute of Standards and Technology, or NIST, began the process of standardizing encryption algorithms called lightweight cryptography for these types of devices.

Many IoT devices are small, low-powered devices that don't have the resources to handle the encryption methods we've covered. IoT devices have limitations such as only having a small amount of RAM and CPU power. Some devices even run on batteries. Lightweight cryptography algorithms must take this into account and still provide high levels of security while being efficient.

### Homomorphic Encryption 07:47-08:53

One huge risk with all encryption is that the data must first be decrypted before it can be used. Homomorphic encryption addresses this concern by allowing encrypted data to be used without decrypting it first. This is done by performing mathematical operations on the ciphertext instead of on the actual data itself. Homomorphic encryption works like other asymmetric encryption methods by using a public key to encrypt the data and a private key to decrypt it.

It helps to look at data as math problems to better understand the differences in the types of homomorphic encryption.

There are three types of homomorphic encryption: Partially homomorphic, which allows for only simple mathematical operations like addition and subtraction to be performed; somewhat homomorphic, which allows for more complex math such as multiplication to occur but only for a limited number of times; and fully homomorphic, which can handle any mathematical operation an unlimited number of times. Homomorphic Encryption has the potential to be a game changer, but as of now it's incredibly slow and inefficient.

### Summary 08:53-09:23

That's it for this lesson. In this lesson, we looked at the different ciphers used in cryptography. We first examined the stream cipher which encrypts data one bit at a time. Then we looked at how block ciphers work and the different operation modes. Finally, we looked at two newer forms of cryptography. Lightweight cryptography is being designed for IoT devices and homomorphic encryption allows data to be used without having to decrypt it.

## 7.1.7 Cryptography Algorithms Facts

The cornerstone of all cryptography is the algorithm, or cipher. There are different types of ciphers in use today.

This lesson covers the following topics:

<ul>
   <li>
    Stream cipher
   </li>
   <li>
    Block cipher
   </li>
   <li>
    Lightweight cryptography
   </li>
   <li>
    Homomorphic encryption
   </li>
  </ul>

### Stream Cipher

A stream cipher is a symmetric encryption method that encrypts data one bit at a time. The stream cipher is based on the one-time pad (OTP) concept, which was used extensively during World War 2. Consider the following OTP characteristics:

<ul>
   <li>
    The OTP uses a symmetric encryption key that is the same length as the data being encrypted.
   </li>
   <li>
    The encryption key is used to encrypt the data using a process called XORing. This means that two binary strings are
      compared. If the bits match, a 0 is generated. If the bits don't match, a 1 is generated. The output of the XOR process
      is the ciphertext.
   </li>
   <li>
    The OTP demonstrates what is called perfect secrecy. This means that it is just as, if not more, difficult for a hacker
      to brute-force the key as it would be to brute-force the data itself.
   </li>
   <li>
    The OTP only provides perfect secrecy if the secret key is only used once. If used more than once, a hacker could begin
      to decode it.
   </li>
   <li>
    OTP works well when dealing with small messages, but it becomes impractical when dealing with large data due to the keys
      being so extensive.
   </li>
  </ul>

A stream cipher solves the problem of having excessively large keys associated with OTP by using a smaller, fixed-length seed key such as one that is 2048 bits in length. The following describes the process of creating a seed key:

<ol>
   <li>
    The seed key is run through a pseudorandom number generator which outputs a new and unique encryption key that is the
      same size as the data being encrypted. This new key is called a keystream.
   </li>
   <li>
    The keystream is XORed with the data to create the ciphertext.
   </li>
   <li>
    The seed key can be used repeatedly throughout the encryption process.
   </li>
  </ol>

While stream ciphers are less secure than the one-time pad, this method can actually be used in real time. One of the most widely used stream ciphers was Rivest's Cipher 4 (RC4). However, multiple vulnerabilities have been discovered in RC4, rendering it insecure. It is no longer used today.

### Block Cipher

Many symmetric encryption algorithms use the block cipher method. Instead of encrypting our data one bit at a time, a block cipher encrypts the data one chunk at a time. Common block sizes are 64, 128, or 256 bits in length. For example, when encrypting a piece of data that is 100 bytes in size using a 256-bit block size, the data would be encrypted 32 bytes at a time (256 bits/8 = 32 bytes). Because the last block is less than 32 bytes, extra random bits are added to bring the block up to 32 bytes.

There are 6 block cipher modes of operation that can be utilized depending on the application or use:

<table>
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Mode of Operation
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Electronic Code Book
     <br>
     (ECB)
    </td>
    <td>
     ECB is the simplest mode of operation.
     <ul>
      <li>
       Each block of plaintext data is encrypted separately.
      </li>
      <li>
       Blocks of data can be encrypted simultaneously allowing for faster encryption.
      </li>
      <li>
       The biggest disadvantage is that blocks with identical data will generate the same ciphertext.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Cipher Block Chaining
     <br>
     (CBC)
    </td>
    <td>
     CBC is similar to ECB except this mode uses an initialization vector (IV).
     <ul>
      <li>
       The IV is a starting variable that is XORed with the plaintext of the current block to encrypt the data.
      </li>
      <li>
       The IV for the starting block is a randomly generated value. Each subsequent IV is the ciphertext from the previous
          block.
      </li>
      <li>
       CBC is more secure than ECB due to the IV, but it is slower because blocks cannot be encrypted simultaneously.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Cipher Feedback Mode
     <br>
     (CFB)
    </td>
    <td>
     CFB also uses an IV, but instead of using it on the plaintext, the IV is encrypted first. That output
        is then XORed with the plaintext to create the block of ciphertext.
     <ul>
      <li>
       This is the equivalent of using a one-time pad to encrypt the data.
      </li>
      <li>
       The IV for the starting block is a randomly generated value. Each subsequent IV is the ciphertext from the previous
          block.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Output Feedback Mode
     <br>
     (OFB)
    </td>
    <td>
     This mode is identical to CFB except for the IV used after the first round.
     <ul>
      <li>
       The output of the IV encryption is used as the next block's ciphertext.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Counter Mode (CTR)
    </td>
    <td>
     Instead of using an initialization vector, CTR uses a nonce combined with a counter that is encrypted.
     <ul>
      <li>
       A nonce is a random string that is used for all blocks during the encryption process.
      </li>
      <li>
       The encrypted output of the nonce and counter is then XORed with the plaintext to create the ciphertext.
      </li>
      <li>
       The counter increments for each block. This ensures that each block uses a different value so that even if blocks
          have the same data, the ciphertext will be different.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Galois Counter Mode
     <br>
     (GCM)
    </td>
    <td>
     All other modes of operation are unauthenticated forms of encryption. The Galois Counter Mode provides
        both encryption and authentication.
     <ul>
      <li>
       GCM works just like Counter Mode except the ciphertext is combined with a special hash.
      </li>
      <li>
       The output of the ciphertext and hash contains the encrypted data along with a Message Authentication Code (MAC) that
          gives assurance the message has not been tampered with.
      </li>
      <li>
       Because GCM is extremely efficient and provides authentication, it is often used with network communications such as
          802.11 and when sending encrypted data to a web server using TLS or SSH.
      </li>
      <li>
       There are other encryption methods that also provide authentication, but GCM is the most widely used method.
      </li>
     </ul>
    </td>
   </tr>
  </tbody></table>

### Lightweight Cryptography

In 2018, NIST began the process to standardize encryption algorithms called lightweight cryptography. Lightweight cryptography is meant to be used on Internet of Things (IoT) devices.

Many IoT devices are small, low-powered devices that don’t have the resources to handle other encryption methods. Some of the limitations of IoT devices that lightweight cryptography needs to address are:

<ul>
   <li>
    Small amount of RAM
   </li>
   <li>
    Low CPU power
   </li>
   <li>
    Low powered or runs on batteries
   </li>
  </ul>

Lightweight cryptography algorithms need to work on these devices efficiently while still providing high levels of security.

### Homomorphic Encryption

An inherent risk with all encryption is that for the data to be worked on (computation on ciphertexts), it must first be decrypted. Homomorphic encryption addresses this concern by allowing data to be worked on without decrypting it first.

There are three types of homomorphic encryption. To explain the differences, it works best to think of data as integers and to use math functions to represent the manipulation of that data.

<table>
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Homomorphic Encryption Type
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Partially Homomorphic Encryption
     <br>
     (PHE)
    </td>
    <td>
     PHE allows only select simple math functions (such as addition) to be performed. This means that only
        one math function can be performed an unlimited number of times on the encrypted values.
    </td>
   </tr>
   <tr>
    <td>
     Somewhat Homomorphic Encryption
     <br>
     (SHE)
    </td>
    <td>
     SHE allows more complex math (such as multiplication) to occur. But it can only be performed a limited
        number of times.
    </td>
   </tr>
   <tr>
    <td>
     Fully Homomorphic Encryption
     <br>
     (FHE)
    </td>
    <td>
     This method can handle both simple and advanced math functions (such as addition 
        and multiplication) being performed an unlimited number of times on the encrypted
        values.
     <p>
      FHE is still in the developmental stage.
     </p>
    </td>
   </tr>
  </tbody></table>

## 7.1.8 Blockchain

### Blockchain 00:00-00:29

A blockchain is a unique and increasingly popular implementation of cryptography. Blockchain technology was developed in 2008 and really came to the public with the release of Bitcoin. It's a decentralized and distributed ledger that uses cryptography to keep data secure and records and verifies transactions between two parties. In this lesson, we'll look at how a blockchain works and some interesting implementations of this newer technology.

### The Blockchain 00:29-01:49

Bitcoin cryptocurrency is the first prevalent use of a blockchain.

The idea is to provide a way for people to make online transactions without the use of a centralized third party, such as a bank. Let's take a closer look at the blockchain and how it works.

Each block is a transaction that's stored in a public database, or the chain. The block contains information about the transaction, including time, date, parties involved, and a unique hash that separates it from other blocks on the chain.

Let's look at this blockchain in action.

Travis is purchasing something from Craig and needs to send him money. Using his personal secret key and Craig's public key, Travis requests the transaction, which is represented online as a block. The transaction is sent out on a peer-to-peer network that consists of a bunch of computers called nodes.

The network verifies the transaction using known algorithms. The transaction is added to the chain, which creates a permanent record that can't be altered or denied. Travis's ownership of the money now transfers to Craig. The entire transaction happens very quickly, usually within a matter of minutes.

What makes the blockchain so secure is that every node contains a copy of the ledger. If a hacker changes a transaction, it won't matter because a copy of the transaction is also on many other computers.

### Nodes 01:49-01:58

Not just anyone can join a blockchain network, however. Each node must prove themselves and actually do some work. This is done through a process called mining.

### Mining 01:58-02:35

Mining is adding blocks to the chain. To do this, extremely complex math computations take place to generate a 64-digit hexadecimal hash. Creating it requires a lot of power and time, so the process is split between each node. As a reward for performing these tasks, the nodes are usually paid with cryptocurrency, like Bitcoin.

Even though each transaction is publicly visible, all personal information is encrypted and hidden from everyone, even the nodes. Because it's a shared ledger and every transaction is publicly available, all persons involved can be held accountable for their actions.

### Blockchain Implementations 02:35-02:45

Sending money isn't the only way blockchain can be used. Some large companies, including Microsoft and IBM, are working to adapt different technologies to the blockchain.

### Transactions 02:45-03:00

Many transactions that currently rely on a paper-based system could benefit from blockchain. For example, car or house titles could be transferred over the blockchain. Because the transactions are transparent, this would create a clear picture of legal ownership.

### Supply Chains 03:00-03:21

We could also use the blockchain to track the movement of things like food from its origin to the market. Any product supply chain could be followed, and the fact that it's all transparent would allow everyone peace of mind because we could see every stop the product has made.

There are many other ways the blockchain could be used, and as the technology becomes more popular, we'll see the blockchain serve many functions.

### Summary 03:21-03:35

That's it for this lesson. In this video, we discussed what a blockchain is and how it works. Then we looked at some implementations of blockchain technology.

## 7.1.9 Blockchain Facts

This lesson covers the following topics:

- Blockchain
- Blockchain implementations

### Blockchain

Blockchain is a unique and increasingly popular implementation of cryptography. A blockchain is a decentralized and distributed ledger that records and verifies transactions between two parties. Blockchain uses cryptography to keep data secure. It was developed in 2008.

Each block is a transaction that is stored in a public database (the chain). A transaction can involve cryptocurrency, contracts, records, or other types of information. The first big use of the blockchain was the cryptocurrency, Bitcoin. The purpose of Bitcoin is to provide a method for people to make online transactions without the use of a centralized third party such as a bank.

Each block contains information about the transaction including:

<ul>
   <li>
    Time
   </li>
   <li>
    Date
   </li>
   <li>
    Parties involved
   </li>
   <li>
    A unique hash that separates the block from other blocks on the chain
   </li>
  </ul>

Each block goes through the same process:

<ol>
   <li>
    User1 requests a transaction with User2. The request is made using User1's personal secret key and User2's public key.
   </li>
   <li>
    The transaction is represented online as a block.
   </li>
   <li>
    The block is distributed to everyone on a peer-to-peer network.
   </li>
   <li>
    The network users verify the transaction is valid.
   </li>
   <li>
    The block is added to the chain. This provides a indisputable and transparent record of the transaction.
   </li>
   <li>
    The contents of the transaction move to User2.
   </li>
  </ol>

The entire transaction happens very quickly, usually within a matter of minutes. Every node contains a copy of the ledger. If a hacker changed a transaction, it wouldn’t matter because a copy of the transaction is stored on many other computers.

Each node plays an important part in the blockchain. Each node must prove itself by performing work before being allowed to join the network. This is typically done through mining.

Mining is the process of adding blocks to the chain. Each block has a 64-digit hexadecimal hash generated by extremely complex math computations. Generating the hash requires a lot of time and computing power. The process is split between each node. As a reward for performing these computations, the nodes are usually paid with cryptocurrency, like Bitcoin.

Even though each transaction is publicly visible, all personal information is encrypted and hidden from everyone, even the nodes. Because it’s a shared ledger and every transaction is publicly available, all persons involved can be held accountable for their actions.

### Blockchain Implementations

Sending money isn’t the only way blockchain can be used. Some large companies, including Microsoft and IBM, are working to adapt different technologies to the blockchain. The following table describes two types of blockchain implmentation.

<table>
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Implementation
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Transactions
    </td>
    <td>
     Many transactions that currently rely on a paper-based system could benefit from blockchain.
        For example, a car or house title could be transferred over the blockchain. Because the transactions are transparent,
        this would create a clear picture of legal ownership.
    </td>
   </tr>
   <tr>
    <td>
     Supply Chains
    </td>
    <td>
     A blockchain could be used to track the movement of product such as food. The ability to follow and
        see every stop the product has made on its way to the consumer would provide assurances of the product's safety.
    </td>
   </tr>
  </tbody></table>

## 7.1.10 Use Steganography to Hide a File

### Use Steganography to Hide a File 00:00-00:26

Sometimes, in order to maintain access to a network or system, malicious users try to transfer files. In this demo, we'll discuss how to hide the contents of a file inside another file using a technique called steganography. People have used steganography to send secret messages for hundreds of years. Typically, this method is used when the sender is concerned that their traffic is being inspected by a third party.

### Use OpenStego 00:26-00:39

We're going to use a free tool called OpenStego that's able to hide a file inside of an image. This tool is very easy to use and has a graphical user interface. We're going to run the tool on Linux, but it's also available on Windows.

### Hide Data 00:39-01:39

When we open up the tool, the first thing we see is the Hide Data screen; since this is the screen we want, let's move on to the fields that need to be filled out. Message File is the name of the file we want to hide in the Cover File, and it will be saved to the Output Stego File. I already have a file I want to hide, so I'll select that now. I'll come over here and navigate down until I find my file, secret-information.txt. Let's click OK.

Now that we've selected the message file, we need to select the file we want to save the message into. I've already downloaded a picture, so we'll select it and then continue. Once again, I'll navigate to my Pictures folder, where I've stored the PNG we're going to use.

Lastly, we need to select where we would like to save the file that we've encoded information into. Let's just call it secret-forest.png and save it in the same folder. I'll click over here and enter in 'secret-forest.png'. We could enter a password here, but we'll just leave it for now. Since that's all the information we need, let's click Hide Data.

### Compare the Files 01:39-02:20

That's it! To see that it worked, let's check to see that the Secret Forest file has been created. I'll browse through my folders to get to the Pictures folder. This is the file we created that contains the hidden data. Let's take a look at the original file to see whether there are any major visual differences. This side-by-side comparison shows that, visually, the images appear to be identical. If we look at the file sizes, though, we can see a bit of a difference between the two. In the lower right-hand corner, you can see that the original image is 10 megabytes, and the file that we encoded data into is almost 12 megabytes. This kind of difference would be difficult to detect if you didn't know the size of the original file.

### Extract Data 02:20-03:10

Now that we see that the new file has been created, we should make sure that the data was stored properly. Let's try to extract the data. Let's go back to OpenStego and click on the Extract Data button. This page is a bit simpler, since the program only needs the new file and a folder to save the extracted file. I'll provide that data now and attempt to extract the data. I'll come over here and select my file. Click OK. Next, we'll just save it in the Pictures folder and select the Extract Data button. We'll wait for a second while it processes.

You can see that a text file was created in the folder. The file has the same name as the file we originally stored in the image, since the steganography tool saves that information in the image as well. We should make sure that the data inside the file is actually correct by opening it. I'll come up here and open the text file. And here's all our secret passwords.

### Summary 03:10-03:21

In this demo, we discussed steganography and methods for saving data to an image and extracting data from an image.

## 7.1.12 Cryptographic Attacks

### Cryptographic Attacks 00:00-00:19

No matter how many barriers we put in place to protect our data, hackers will always try to figure out a way to get around them and steal valuable information.

In this video, we're going to look at some common cryptographic attacks and what the future of cryptography might look like.

### Cryptographic Attacks 00:19-00:38

Encrypted data is usually secure, but there are no guarantees in the security world. By using new, targeted, or sophisticated attacks, hackers might be able to decrypt data you thought was safe. Some of the more common attacks are dictionary attacks, collision attacks, birthday attacks, and downgrade attacks.

### Dictionary Attack 00:38-00:59

A dictionary attack is a type of brute force attack that is used quite often. In this attack, the hacker has a huge list of words and phrases that are used to guess a decryption key. These attacks work well against weak passwords, such as password123. Using longer and uncommon passphrases is the key to beating dictionary attacks.

### Collision Attack 00:59-01:50

Another type of attack is the collision attack. A collision attack tries to find two inputs that produce the same hash value. This type of attack is often used on digital signatures.

For example, we have a hacker that creates two different documents that have an identical hash value. With this type of attach, the hacker wants to get Travis to accept the second document by making it seem that it came from Craig.

The first document is sent to Craig, who agrees with what the document says, so he signs it and sends it back. The hacker then takes Craig's signature from that document, attaches it to a bad document, and sends that to Travis. Because the documents have the same hash, Travis' software is unable to detect that there's anything wrong, and it looks totally legitimate. The problem with this attack is the difficulty of generating two documents that have the same hash.

### Birthday Attack 01:50-02:21

A birthday attack combines a collision attack and a brute force attack. This attack's name is taken from the birthday probability math problem.

If you have 30 people are in a room, the chance that someone has the same birthday as you is about 8 percent. But the probability that any two people in the room have the same birthday is 70 percent. This is because we're not looking for an exact match, just any match. This concept can be used to create two documents with the same hash, as in the collision attack example.

### Downgrade Attack 02:21-03:23

Another popular attack is the downgrade attack. These attacks are often used as part of the man-in-the-middle method. Downgrade attacks force the system to use an older, less secure protocol for communication.

A common example of this attack is SSL exploitation. Many servers have both SSL and TLS installed on them. If a client can't use TLS, then the server can revert to SSL. A hacker can set up their computer to only use SSL, which will then allow them to launch SSL-based attacks on the server.

Another common example is a man-in-the-middle attack. In this attack, the hacker intercepts the HTTPS packets and reverts them to HTTP packets. If the server isn't configured properly, it'll respond using HTTP, which allows the hacker to see everything being sent back and forth.

To combat these attacks, it's imperative that servers don't support older, less secure protocols. Proper server configuration is the key to stopping these types of attacks.

### Quantum Cryptography 03:23-04:01

Now let's look ahead to what's coming in the security world. The future of computers and cryptography lies in quantum computing.

Classic computing works by processing bits, or 0s and 1s. These bits represent the electrical signals of on and off. Quantum computing uses qubits, which can exist as both a 1 and 0 at the same time. Quantum computing is so much more powerful than today's computing.

This increased computing power means that today's encryption standards can be hacked easily and quickly. An encryption key that might take years to crack with today's computers can take days or even hours with quantum computers.

### Post-Quantum Cryptography 04:01-04:12

To combat the inevitable increase of quantum computing, researchers have already started work on post-quantum cryptography. These new methods will be used to ensure the safety of our data.

### Summary 04:12-04:32

That wraps up this lesson. In this video, we covered different types of cryptographic attacks, including dictionary, collision, birthday, and downgrade attacks. Then we looked at the future of cryptography, which involves quantum computing and post-quantum cryptography.

## 7.1.13 Cryptographic Attack Facts

Hackers attempt to figure out a way to get to data they want. Encrypting data is usually relatively secure, but there is unfortunately no such thing as a sure thing when it comes to protecting data. By using different types of attacks, hackers might be able to gain access to encrypted data.

This lesson covers the following topics:

- Common cryptographic attacks
- Future of cryptography

### Common Cryptographic Attacks

The following table covers some of the more common cryptographic attacks.

<table>
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Attack Method
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Dictionary
    </td>
    <td>
     A dictionary attack is a type of brute-force attack. The hacker uses a list of words and phrases to try
        to guess the decryption key.
     <ul>
      <li>
       Dictionary attacks work well if weak passwords are used.
      </li>
      <li>
       Using longer and uncommon passphrases is the best way to secure data against these attacks.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Collision attack
    </td>
    <td>
     A collision attack tries to find two inputs that produce the same hash value. This type of attack is
        often used on digital signatures.
     <ul>
      <li>
       If a hacker wanted to get User2 to sign a document by making it seem like it came from User1, the hacker would
          generate two documents that generate the same hash.
      </li>
      <li>
       The hacker would send one document to User1 and get that signature.
      </li>
      <li>
       The signature would be attached to the second document and sent to User2. Because the hashes are identical, User2
          thinks the document is legitimate and has been signed by User1.
      </li>
     </ul>
     <br>
     Generating longer hash outputs is the key to stopping these types of attacks.
    </td>
   </tr>
   <tr>
    <td>
     Birthday attack
    </td>
    <td>
     This attack combines a collision attack and brute-force attack. The name is taken from the birthday
        probability math problem.
     <br>
     <br>
     The birthday probability math problem states that if you have 30 people in a room, the probability that someone has
        the same birthday as you is approximately 8%. However, the probability that any two people in the room have the same
        birthday is 70%. This is because we’re not looking for an exact match (just any match), so the probability is higher.
        Digital signatures can be susceptible to birthday attacks.
     <br>
     <br>
     Generating longer hash outputs is the key to stopping these attacks.
    </td>
   </tr>
   <tr>
    <td>
     Downgrade attack
    </td>
    <td>
     A downgrade attack forces the system to use an older, less secure communication protocol.
     <ul>
      <li>
       SSL exploitation is a common implementation of this attack. A hacker can set up their computer to only use SSL so
          that when the request is sent to the server, the server downgrades from TLS to SSL to communicate. This then allows the
          hacker to launch SSL-based attacks on the server.
      </li>
      <li>
       Downgrade attacks are often used as part of a man-in-the-middle (MITM) attack. The hacker can intercept a HTTPS
          packet and downgrade it to a HTTP packet. If the server is not configured properly, the server responds using HTTP. This
          allows the hacker to now see all communications.
      </li>
     </ul>
     <br>
     To prevent downgrade attacks, servers must be set up to not support these older and less secure protocols. Proper
        server configuration is the key to stopping these types of attacks.
    </td>
   </tr>
  </tbody></table>

### Future of Cryptography

The future of computers and cryptography lies in quantum computing.

Classic computing works by processing bits of 1s and 0s. These bits represent electrical signals, on and off. Quantum computing uses qubits which can exist as both a 1 and 0 at the same time. Quantum computing is exponentially more powerful than today's computing standards.

This increased computing power means that today’s encryption standards can be hacked easily and quickly. An encryption key that might take years to crack with today’s computers can take days or even hours with quantum computers.

To combat the inevitable increase of quantum computing, researchers have already started work on post-quantum cryptography. These new methods will be used to ensure the safety of our data in the future.
