---
lang: zh-CN
title: Section 6.7 Linux Users
description: some description
---

As you study this section, answer the following questions:

<ul>
    <li>
     How can you view the default values in the /etc/default/useradd file?
    </li>
    <li>
     How do you create a user in Linux?
    </li>
    <li>
     Which command deletes a user and the user's home directory at the same time?
    </li>
    <li>
     What is the difference between hard and soft limits?
    </li>
    <li>
     Which command removes all restrictions for process memory usage?
    </li>
    <li>
     Why shouldn't passwords expire too frequently?
    </li>
    <li>
     Which directory contains configuration file templates that are copied into a new user's home directory?
    </li>
   </ul>

In this section, you will learn to:

<ul>
    <li>
     Create a user account.
    </li>
    <li>
     Rename a user account.
    </li>
    <li>
     Delete a user.
    </li>
    <li>
     Change your password.
    </li>
    <li>
     Change a user's password.
    </li>
    <li>
     Lock and unlock user accounts.
    </li>
   </ul>

The key terms for this section include:

<table class="terms">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Term
    </th>
    <th scope="col" class="fw-bold">
     Definition
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     daemon
    </td>
    <td>
     A Linux or UNIX program that runs as a background process, rather than being under the direct control of an interactive user.
    </td>
   </tr>
  </tbody></table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Exam
    </th>
    <th scope="col" class="fw-bold">
     Objective
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     TestOut Security Pro
    </td>
    <td>
     1.0 Identity Management and Authentication
     <blockquote>
      1.1 Manage Identity
      <br>
      1.2 Harden Authentication
     </blockquote>
    </td>
   </tr>
   <tr>
    <td>
     CompTIA Security+ SY0-601
    </td>
    <td>
     3.7 Given a scenario, implement identity and account management controls.
     <ul>
      <li>
       Account types
       <ul>
        <li>
         User account
        </li>
        <li>
         Shared and generic accounts/credentials
        </li>
        <li>
         Guest accounts
        </li>
        <li>
         Service accounts
        </li>
       </ul>
      </li>
      <li>
       Account policies
       <ul>
        <li>
         Password complexity
        </li>
        <li>
         Password history
        </li>
        <li>
         Password reuse
        </li>
        <li>
         Time of day
        </li>
        <li>
         Network location
        </li>
        <li>
         Geofencing
        </li>
        <li>
         Geotagging
        </li>
        <li>
         Geolocation
        </li>
        <li>
         Time-based logins
        </li>
        <li>
         Access policies
        </li>
        <li>
         Account permissions
        </li>
        <li>
         Account audits
        </li>
       </ul>
      </li>
     </ul>
    </td>
   </tr>
  </tbody></table>

## 6.7.1 Linux User and Group Overview

### Linux User and Group Overview 00:00-00:33

In this video, we're going to discuss Linux users and groups. First, when you're working with Linux, it's important to understand that it's a true multi-user operating system. Each user account has their own unique, customizable computing environment. When user accounts are stored locally, Linux stores the user, group, and password information in three separate files on the local file system in the /etc directory. We'll discuss each of these files in this lesson.

### Password File 00:33-04:02

The first file is the passwd file. The password file is named passwd, and it's stored in the /etc directory. This file contains the user account information for your system; this is where your users are defined. But don't let the filename confuse you. This file doesn't contain any password information, only user account information. Passwords are stored in another file that we'll look at in a bit.

You may hear people still refer to this file as the password file because in the early days of UNIX, passwords were stored in here alongside the usernames. But, as you can imagine, this presented a huge security risk, so this file no longer contains any passwords. To avoid confusion, I'll call this the passwd file.

So, now, the passwd file is where all the user accounts are stored. Each user account on a system is represented by a single line called an account record. An account record is composed of several fields, each separated by a colon.

The first field is the username. The second is the password field. The third is the user ID field. Then there's the group ID field, the full name field, the home directory field, and finally, the shell field.

Let's look at an example of each field. The username field contains the username the user will use to log in to the system. For example, for this record, the user account is zday. Next, we have the password field. Since this is a remnant of when passwords used to be stored in this file, you'll only see an X in this field. Now passwords are stored in the shadow file, which we'll talk about in a bit. Next is the UID field. This contains the user ID that's assigned to the user account. This user account is assigned a UID number of 1001.

Then we have the group ID field, which references the group ID number of the user's default group. In Linux, a single user account can be a member of several different groups, but by default, a user is always assigned to one group, the default group. This is almost always the Users group, which has an ID of 100.

Next, we have the full name field, which just contains the user's full name. The next field specifies the user's home directory. And finally, the default shell field specifies which shell is going to run for the user by default. Most distributions set the default shell to /bin/bash.

It's important to understand that the passwd file contains two different types of users. First, there's the standard user accounts. These accounts are used to log in to the system, such as the zday account we just saw.

The second type of accounts are the system user accounts. These accounts can't be used to log in to the system. They're used by services or daemons that are running on the system. This is because Linux uses groups, users, and permissions to control privileges. For a service or daemon to be able to read from or

write to the file system, it needs to have a user account. So, if you ever open the passwd file and wonder why there are so many users that you never created, it's because the passwd file contains both standard user accounts.

### Shadow Files 04:02-08:45

Now let's talk about the shadow file, which is where passwords are stored these days.

The shadow file is linked to the passwd file. Each user account defined in your passwd file has a corresponding entry in the shadow file. As with the passwd file, each user account is represented by a single line in the shadow file called a record, which is composed of several different fields separated by colons.

Here's an example of a single record in the shadow file.

First, we have the username field, which is the same username that's defined in the passwd file. This is what links the two records together. Next, we have the password field. Depending on the type of user account you're looking at, there are a few things you can see in the password field.

For example, if the record is for a standard user account, the password field will contain a string of text. This is the user's actual password in encrypted format. Theoretically, it's possible to crack this encrypted password if someone were to gain access to this file. But it's extremely difficult to do, and it would take a very, very long time.

If the record is for a system user account, the password field will contain an asterisk. Remember, system user accounts can't be used to log in to the system. The asterisk indicates that this account is disabled, which prevents it from being able to authenticate to the system.

There's one more thing you might see in the password field: a blank entry. Nothing. This means that the user account doesn't have a password and doesn't require one to log in to the system. As you can imagine, this presents a huge security hole. A user account should always have either an encrypted password or an asterisk, not a blank entry.

The next field is the last modified field. This field displays the numbers of days since January 1st, 1970 that the password was last changed. So, when you see a huge number here, just remember that it's counting all the days between January 1st, 1970, and the day the password was last changed.

Next, we have the minimum days field. This field defines the minimum number of days that need to pass before a password can change. Usually, this is set to zero, which means the password can be changed any time. But if you want to make it so users need to keep the same password for at least a week, you could put a seven in this field.

The next field is the maximum days field. This field defines the maximum number of days a password can be used. For example, if you want users to change their password after 90 days, you would enter '90' in this field, or you can set passwords to never expire by entering ‘99999' here.

Next, we have the days warning field. This field defines when a user will be warned that their password is about to expire. This field is usually set to five or seven days.

The next field defines the number of days to wait after a password is expired to disable the account. This field is usually set to -1, which disables this functionality. But if you want to disable an account if its password isn't changed after it expires, then you can enter a number, 3 for example.

And finally, we have the expire field. This field defines the number of days since January 1st, 1970, that must pass until the account is automatically disabled. By default, this field is blank, which means this functionality is disabled. But if you want an account to be automatically disabled on a specific date, you need to figure out the number of days between it and January 1st, 1970, and then enter that number. And don't worry, there are several tools available that can do this calculation for you.

Now, because the passwd and shadow files work together, they need to stay synchronized. The main way these files become out of sync is when an administrator uses a text editor to make changes to one of the files, but forgets to make the changes to the other, such as changing a username. If the files don't match, you've got a problem.

To avoid this, manage user accounts using the password and user management utilities that are provided by the operating system. Avoid using a text editor. If a problem does occur, there are few commands you can use to compare the passwd file and shadow file, such as pwck, and then re-synchronize the files if they don't match.

### Group Files 08:45-10:44

Now, let's look at the third file, the /etc/group file. Like most operating systems,

Linux uses groups to help ease system management. For example, instead of managing the privileges of each individual user, you can manage the privileges of a single group and then assign user accounts to that group.

Now, any changes made to the group will be automatically applied to the users. If you're managing hundreds of users, groups make your job a lot easier. Groups on a Linux system are defined in the /etc/group file. And the structure of the group file is similar to the passwd and shadow files.

Each line in the group file is a single record that defines one group on your system, and each record is composed of four fields separated by colons. The first field is the group field. It specifies the group's name. In this example, the name of the group is sales. The second field is the password field, which specifies a password for the group. This field is rarely used, and in most cases it'll contain an X, which means no password is set. The third field is the group ID number, or the GID. In this case, the GID is 33. And the last field is a list of users who are members of the group. In this example, you see that zday and rnelson are both members of the sales group.

Keep in mind that some Linux distributions use an additional group file to store group passwords. This works in a similar way to the passwd and shadow files. With this model, group passwords are stored in the gshadow file. Like the group file, the gshadow file has corresponding records and fields that define each group. In the gshadow file, you'll see fields that define the group name, the password, the group admins, and the group members.

### Summary 10:44-11:14

So that's how Linux users and groups work on a Linux system. In this lesson, we talked about user account storage. First, we looked at the /etc/passwd file, which contains user account information. Then we looked at the shadow file, which contains user passwords and password settings. And finally, we looked at the group file, where groups and group members are defined.

## 6.7.2 Managing Linux Users

### Managing Linux Users 00:00-00:34

In this demonstration, we're going to talk about managing Linux user accounts. As a Linux administrator, there will be times when you have to add, remove, or modify user accounts. Let's begin by looking at the User Add utility.

As a root user, you type ‘useradd' followed by any options you might want and then the username. It's important to note that if you create a user in the shell prompt with useradd, it will automatically use the default values contained and the /etc/default/user add file.

### Create a User Account 00:34-02:02

Let's look at that file right now with 'less /etc/default/useradd'. Notice that the useradd commands use the default values. First, look at the default home directory, specified as the /home directory.

That's where the user's default profile, or default directory, will be created. There's no expiration date set by default for the account. The shell is bin/bash, and the skeleton file is etc/skel.

This is useful if you have specific files or folders that you want to be in each new user's home directory. You can simply place them in the skeleton directory, and then they're automatically created in the new user's home directory. We can see here, at the bottom, that a mail spool for the user account will also be created. You can go into this file using the VI editor and change these default values if you need to.

For example, if you want the home directory to be in a different location by default, you can set that default by typing ‘useradd -D' at the shell prompt. You need to also be aware that the less /etc/login.defs file is used to configure the values that can be used for the group ID and the user ID.

If we hit Enter and scroll down, we can see here that the values for the group ID and the user ID are specified, so you can see the minimum value for the user ID on this Linux version is 1000. Also, for the group ID, the minimum is set to 1000. Let's exit out of that.

### UserAdd Command 02:02-03:29

Now let's talk about useradd. Like I said before, you can override the default values using command line options.

We'll take a look at the man page for useradd, ‘man useradd'. This will show you all the available options for the useradd command. A few examples are -c to specify a comment for the user's full name, -g (lowercase) to add a single primary group, and -G (uppercase) to add supplementary groups separated by commas.

Let's look at an example. Suppose we want to create a user named ksanders whose full name is Kim Sanders. We want to create a home directory, and we want to specify the user's name as we create the account. Let's go ahead and type in 'sudo useradd'.

Now we want to use the -c option to specify the user's full name. We're going to put in ‘"Kim Sanders"' in quotes. Then we're going to use the ‘-m' option to create the user's home directory and specify the username as ‘ksanders'. Press Enter.

After suppling the sudo password to add the account, we can verify that was created by looking at our etc/passwd file. If we scroll down, we can see a few things here. You can see the group and user ID, 1002, 1002.We can see the full name, Kim Sanders, and we can also see the ksanders folder within the home directory.

### Add Passwords to User Accounts 03:29-04:40

ksanders doesn't have a password yet. On Linux, if the user account doesn't have a password, then the password is locked. We can verify this by typing in 'sudo passwd -S' followed by the username, 'ksanders'.

Now we can see this LK, which tells us that the account is locked. So, before the user can log in, we have to enable the account by adding a password.

We need to type 'sudo passwd' followed by the user account, 'ksanders'. Hit Enter. It wants us to create a password. We're going to type '1234' just for now. This is just a test account, so that password is fine. Retype the password, '1234'. We get a warning about the password length, but the password updates successfully. Now we want to verify that, so we're going to retype ‘sudo passwd-S ksanders'.

You can see now that this has changed to a PS from an LK. That indicates that a password has been unlocked and is now set up for this account. Now this user can actually log in to this profile.

### Modify User Accounts 04:40-05:38

From time to time, you may need to modify an existing user. This is done with the usermod command. usermod's options are pretty much the same as useradd's.

For example, let's say we entered the wrong full name for the ksanders account. Her name is actually Kimberly. We can go ahead and change this by typing 'sudo usermod - c' and then putting the correct name, 'Kimberly Sanders', closed single quotations, and then the user account, 'ksanders'.

Now we want to verify those changes. We're going to go to 'less /etc/passwd' and scroll to the bottom. We can see that 'Kim Sanders' has actually changed to 'Kimberly Sanders'.

You can use other options with the usermod command to change user account information, such as the username itself, the user ID, the default group, and the home directory.

### Delete a User Account 05:38-07:34

The last thing we want to look at is the user delete, or userdel, command. This command is used to remove an account. We're going to remove the ksanders account.

There's only one option we can use with userdel, and that's the -r option. By default, if you don't use the -r option, the userdel command won't delete the user's home directory from the file system. This is because there might be intellectual property in that directory that you need to keep, even if you delete the user account. But if you do want to delete the home directory along with the user account, you can use the -r option. Let's go ahead and type this in, 'sudo userdel ksanders -r'. We're not going to hit Enter just yet because I want to show you another way of adding and maintaining user accounts.

Sometimes, depending on the distribution, you can actually do this through a GUI or graphical user interface within Linux. Some Linux systems have them, and some don't. Sometimes you can download them. This system already has one. Let's go ahead and click on the dropdown by the power button and click Settings. Scroll down to Details and click Users. Here's our Kim Sanders account. It looks like the name didn't update to Kimberly in the GUI, but we do know it changed because we just saw that in the command line. If I were to unlock this, I could go in and manage this account.

Here, I can do things such change the account type or reset the password. It'll show me my login history as well. I'm not actually going to do anything from here, but I did want to show you that because I want to show you how the account is actually removed.

If I go ahead and I run this command, now the user is deleted. If we go back and look at the ‘/etc/passwd' file and scroll down, you can see the account is deleted.

### Summary 07:34-08:00

That's it for this demonstration. In this demo, we talked about managing Linux users using the shell prompt. We looked at the useradd command, the usermod command, the passwd command, and the userdel command.

We also looked at the graphic interface that some Linux systems will use, and we looked at other options for each command.

## 6.7.3 Linux User Commands and Files

This lesson covers the following topics:

- User files
- User management commands

### User Files

Linux is extremely flexible regarding where user and group information is stored. The options for storing the information are:

<ul>
   <li>
    Local file system
   </li>
   <li>
    LDAP-compliant database
   </li>
   <li>
    Network Information System (NIS). NIS allows many Linux computers to share a common set of user accounts, group accounts,
    and passwords.
   </li>
   <li>
    A Windows domain
   </li>
  </ul>

When files are stored in the local file system, the following files are used:

<table>
   <thead>
    <tr><th scope="col" class="fw-bold">
     File
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     /etc/passwd
    </td>
    <td>
     The /etc/passwd file contains the user account information. Each user's information is stored in a single line on this
        file. There are two types of accounts in a Linux system:
     <ul>
      <li>
       Standard accounts (these are user accounts).
      </li>
      <li>
       System user accounts (these are used by services).
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     /etc/shadow
    </td>
    <td>
     The /etc/shadow file contains the users' passwords in an encrypted format. The shadow file is linked to the /etc/passwd
        file. There are corresponding entries in both files, and they must stay synchronized. There are password and user
        management utilities provided by the system that allow you to edit the files and keep them synchronized. You can use the
        following commands to identify errors and synchronize the files:
     <ul>
      <li>
       <b class="fw-bold">
        pwck
       </b>
       verifies each line in the two files and identifies discrepancies.
      </li>
      <li>
       <b class="fw-bold">
        pwconv
       </b>
       adds the necessary information to synchronize the files.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     /etc/group
    </td>
    <td>
     As with Active Directory, groups can be used to simplify user access to network resources. The /etc/group
      file contains information about each group.
    </td>
   </tr>
  </tbody></table>

Be aware of the following configuration files when managing user accounts:

<table>
   <thead>
    <tr><th scope="col" class="fw-bold">
     File
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     /etc/default/useradd
    </td>
    <td>
     The /etc/default/useradd file contains default values used by the
     <b class="fw-bold">
      useradd
     </b>
     utility when creating a user account,
        including:
     <ul>
      <li>
       Group ID
      </li>
      <li>
       Home directory
      </li>
      <li>
       Account expiration
      </li>
      <li>
       Default shell
      </li>
      <li>
       Secondary group membership
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     /etc/login.defs
    </td>
    <td>
     The /etc/login.defs file contains:
     <ul>
      <li>
       Values used for the group and user ID numbers
      </li>
      <li>
       Parameters for password encryption in the shadow file
      </li>
      <li>
       Password expiration values for user accounts
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     /etc/skel
    </td>
    <td>
     The /etc/skel directory contains a set of configuration file templates that are copied into a new user's home directory
        when it is created, including the following files:
     <ul>
      <li>
       .bashrc
      </li>
      <li>
       .bash_logout
      </li>
      <li>
       .bash_profile
      </li>
      <li>
       .kshrc
      </li>
     </ul>
    </td>
   </tr>
  </tbody></table>

### User Management Commands

Although it is possible to edit the /etc/passwd and /etc/shadow files manually to manage user accounts, doing so can disable your system. Instead, use the following commands to manage user accounts:

> If you are logged in as the root user, the commands in the table can be run by typing the applicable command and its options. However, if you are not logged in as the root user, you will need to use the sudo or su command to gain the permissions required.
> For example, to create a new user named Kim Sanders, you would run: `sudo useradd -c "Kim Sanders" -m ksanders`

<table>
   <thead>
    <tr><th scope="col" class="fw-bold">
     Command
    </th>
    <th scope="col" class="fw-bold">
     Command Function
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     <b class="fw-bold">
      useradd
     </b>
    </td>
    <td>
     Create a user account. The following options override the settings as found in /etc/default/useradd:
     <ul>
      <li>
       <b class="fw-bold">
        -c
       </b>
       adds a description for the account in the GECOS field of /etc/passwd.
      </li>
      <li>
       <b class="fw-bold">
        -d
       </b>
       assigns an absolute pathname to a custom home directory location.
      </li>
      <li>
       <b class="fw-bold">
        -D
       </b>
       displays the default values specified in the /etc/default/useradd file.
      </li>
      <li>
       <b class="fw-bold">
        -e
       </b>
       specifies the date on which the user account will be disabled.
      </li>
      <li>
       <b class="fw-bold">
        -f
       </b>
       specifies the number of days after a password expires until the account is permanently disabled.
      </li>
      <li>
       <b class="fw-bold">
        -g
       </b>
       defines the primary group membership.
      </li>
      <li>
       <b class="fw-bold">
        -M
       </b>
       defines the secondary group membership.
      </li>
      <li>
       <b class="fw-bold">
        -m
       </b>
       creates the user's home directory (if it does not exist).
      </li>
      <li>
       <b class="fw-bold">
        -n
       </b>
       does not create a group with the same name as the user (Red Hat and Fedora, respectively).
      </li>
      <li>
       <b class="fw-bold">
        -p
       </b>
       defines the encrypted password.
      </li>
      <li>
       <b class="fw-bold">
        -r
       </b>
       specifies that the user account is a system user.
      </li>
      <li>
       <b class="fw-bold">
        -s
       </b>
       defines the default shell.
      </li>
      <li>
       <b class="fw-bold">
        -u
       </b>
       assigns the user a custom UID. This is useful when assigning ownership of files and directories to a
          different user.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     <b class="fw-bold">
      passwd
     </b>
    </td>
    <td>
     Assign or change a password for a user.
     <ul>
      <li>
       <b class="fw-bold">
        passwd
       </b>
       (without a user name or options) changes the current user's password.
      </li>
      <li>
       Users can change their own passwords. The root user can execute all other
       <b class="fw-bold">
        passwd
       </b>
       commands.
      </li>
     </ul>
     Be aware of the following options:
     <ul>
      <li>
       <b class="fw-bold">
        -S username
       </b>
       displays the status of the user account. LK indicates that the user account is locked, and PS
          indicates that the user account has a password.
      </li>
      <li>
       <b class="fw-bold">
        -l
       </b>
       disables (locks) an account. This command inserts a !! before the password in the /etc/shadow file,
          effectively disabling the account.
      </li>
      <li>
       <b class="fw-bold">
        -u
       </b>
       enables (unlocks) an account.
      </li>
      <li>
       <b class="fw-bold">
        -d
       </b>
       removes the password from an account.
      </li>
      <li>
       <b class="fw-bold">
        -n
       </b>
       sets the minimum number of days after a password exists before it can be changed.
      </li>
      <li>
       <b class="fw-bold">
        -x
       </b>
       sets the number of days before a user must change the password (password expiration time).
      </li>
      <li>
       <b class="fw-bold">
        -w
       </b>
       sets the number of days before the password expires that the user is warned.
      </li>
      <li>
       <b class="fw-bold">
        -t
       </b>
       sets the number of days following the password expiration that the account will be disabled.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     <b class="fw-bold">
      usermod
     </b>
    </td>
    <td>
     Used to modify an existing user account;
     <b class="fw-bold">
      usermod
     </b>
     uses several of the same switches as
     <b class="fw-bold">
      useradd
     </b>
     . Be aware of
        the following switches:
     <ul>
      <li>
       <b class="fw-bold">
        -c
       </b>
       changes the description for the account.
      </li>
      <li>
       <b class="fw-bold">
        -l
       </b>
       renames a user account.
      </li>
      <li>
       <b class="fw-bold">
        -L
       </b>
       locks the user account. This command inserts a ! before the password in the /etc/shadow file, effectively
          disabling the account.
      </li>
      <li>
       <b class="fw-bold">
        -U
       </b>
       unlocks the user account.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     <b class="fw-bold">
      userdel
     </b>
    </td>
    <td>
     Remove the user from the system. Be aware of the following options:
     <ul>
      <li>
       <b class="fw-bold">
        userdel
        <i class="fs-italicize">
         [username]
        </i>
       </b>
       (without options) removes the user account.
      </li>
      <li>
       <b class="fw-bold">
        -r
       </b>
       removes the user's home directory.
      </li>
      <li>
       <b class="fw-bold">
        -f
       </b>
       forces the removal of the user account even when the user is logged into the system.
      </li>
     </ul>
    </td>
   </tr>
  </tbody></table>

## 6.7.10 Linux User Security and Restrictions

### Linux User Security and Restrictions 00:00-00:16

If you manage Linux systems, one of your key responsibilities is ensuring user security. Today, user security is paramount, and you need to ensure that the data on your systems is secure.

### chage Command 00:16-01:59

There are many aspects to configuring strong user security. Some are implemented by the Linux operating system itself, such as using the chage command to configure password aging, using ulimit to specify limits on resources, and so on. Other aspects involve user training, such as using strong passwords.

You need to train your users to use strong passwords. Have them create passwords that are more than eight characters in length. They should have numbers in the passwords as well as letters. They should use uppercase and lowercase characters in the password, and it should not be a word found in the dictionary. If you teach users these basic principles it'll go a long way in preventing them from using weak passwords.

Another thing you can do is configure your user passwords to expire after a period of time. This is called password aging. The longer a user has the same password, the more likely it is that it will be compromised at some point. Some organizations may mandate a maximum password age of 30 days. Others may specify 60 days. Others may even be 90 days.

You can configure password aging using the chage command, which stands for change age. The syntax for using chage is shown here. We enter chage at the shell prompt followed by the options we want to specify, and then the name of the user we want to apply the password aging policy to. You can use the option shown here with the chage command.

You can enter -m, followed by a number, which represents the minimum number of days required between password changes. You can use -M, followed by a number, which represents the maximum number of days allowed between password changes, and then the -W option, which specifies the number of warning days before the password change is required. You can use this option to specify how far in advance users need to be warned of an expiring password.

### User Limits 01:59-02:26

Next, let's talk about configuring user limits. You can impose limits on how many times users may log concurrently into your system. You can configure how much CPU time they're allowed to use. You can configure how much system RAM they're allowed to use, and so on. This is done using a Pluggable Authentication Module (PAM) named pam_limits. You configure the pam_limits module using a file in the /etc/security directory named limits.conf.

### limits.conf File Configuration 02:26-04:12

The syntax you use in the limits.conf file is shown here. First, you specify the entity you're going to apply the limit to. This could be a user, it could be a group, or you could use a wildcard character. For example, you could use an asterisk to apply a limit to all users. To apply them to a specific user, you enter the user name. To apply them to a group, you have to put an —œat— sign in front of its name to indicate that this is a group, not a user name.

Next you identify the type of limit you want to set. You can use two different values, either a hard limit or a soft limit. A hard limit is a limit that cannot be exceeded. A soft limit is a limit that the user is allowed to exceed temporarily. Next you specify the limit you want to apply. There are lots of different values you can use in the limit field. Some of the more useful ones are listed here. First is core, which specifies the size of the user's core files.

Next is data, which specifies how much room a program can use in RAM. Then we have fsize, which limits the size of the files that the user can create. We have nofile, which limits the number of open data files the user can have. You can specify CPU, which specifies a limit in terms of the amount of CPU time a single process can use. We have nproc, which limits the number of concurrent processes. We have maxlogins, which limits the number of simultaneous logins. And then we have priority, which is used to set process priority limits.

Then you specify a value for the limit you specified. In this example, suppose I want to configure the rtracy user with a hard CPU limit that limits a single process to five minutes maximum of CPU time. To do this, in the limits.conf file I would enter rtracy hard cpu 5.

### ulimit Command 04:12-07:00

In addition to using the limits.conf file, you can also use the ulimit command at the shell prompt to configure resource limits for a given user on your Linux system. It can be used to either view the user's current resource usage limits or you can use it to set the user's current resource usage limits. It's important to note that the ulimit command only restricts access to resources for programs that are launched from the shell prompt as that user account.

If you're running graphical applications, the ulimit resource limits are not applied. Limits that you set with the command will only be applied to executables that are launched from the shell prompt. They will not be applied to applications that might be launched graphically, such as double-clicking on an icon in the graphical desktop.

Let's take a look at the syntax for using ulimit. We enter ulimit, followed by the options we want to apply, and then the limit we want to set. Some of the options you can use with ulimit are listed here. These are not all of the options. If you want to see all of them open up the ulimits man page.

These are just some of the more useful ones here. -c is used to set the maximum size of core files. If you have an application that crashes, and it needs to make a core dump, you can use this option to specify how big those dump files can be. This is usually set to zero by default so that no core dump files can be created. If you do want to enable core dump files, set it to a different value.

The next option is -f. This is used to set the maximum size of files that are created by a shell session. -n is used to set the maximum number of open files on the system. Next is the -t option, which allows us to set the maximum amount of CPU time (in seconds) a process can use. Next is the -u option, which specifies the maximum amount of processes a single user is allowed to run.

Next is the -d option, which allows us to specify the maximum size in memory that a particular process's data segment can occupy. We have -H that allows us to set a hard resource limit, and then we have -S, which allows us to set a soft resource limit.

If you want to just view the limits that are currently assigned you can use the -a option. For example, if you enter ulimit -a, it displays all the limits that have been configured for my user account. Suppose we want to limit the user to a maximum of 5 concurrent processes on the system, and we want it to be a soft limit we'll allow them to exceed it temporarily, if necessary. To do this, we would enter ulimit -S -u 5.

### Summary 07:00-07:15

That's it for this lesson. We discussed some basic Linux user security principles that you should be aware of, such as using strong passwords, aging passwords, and configuring user limits.

## 6.7.11 Configuring Linux User Security and Restrictions

### Configuring User Security and Restrictions 00:00-00:17

In this demonstration, we're going to talk about configuring user restrictions. We're going to look at this topic from three different aspects: password aging, setting login limits, and then setting user limits with the ulimit command.

### Password Aging 00:17-02:22

Let's begin by talking about password aging. In today's security environment, you need to be very careful that you configure your passwords to expire after a set period of time. This is called password aging. The key thing to remember here is that the longer a user has the same password, the more it likely it is to be compromised. To prevent this, you need to configure aging for your user password. This is done with the chage command.

Let's look at the 'chage' man page. The syntax for using chage is to enter the chage command followed by a series of options and then the user account that you want to apply those options to. Some of the more useful options you can use are listed right here. First, we have the lowercase -m option, which specifies the minimum number of days between password changes. You also have the uppercase -M option, which specifies the maximum number of days between password changes. And then we have the -w option that specifies the number of warning days a user gets before the password change is required. Go ahead and exit out of the man page.

Let's work through an example. I'm going to enter 'chage' at the shell prompt as my root user. Then I'm going to specify the capital '-M' option to set the maximum number of days between password changes. Let's set that to two months. For many organizations, that would be way too long. A lot of organizations force password changes every 30 days. Let's specify '-w' to specify that a warning is given seven days before the password is about to expire, so the user has plenty of time to make the change before the password actually expires.

Then we must specify who we want to apply this change to. Let's apply it to our rmckay user account. The password is set to expire for the rmckay user in 60 days. Let's use the 'tail' command to verify this by viewing the /etc/shadow file. Look at the very end of the file. Take a look at the rmckay user account. We can see here that the maximum number of days between password changes is 60, and the rmckay user will get seven warning days to change their password before it expires.

### Configure User Limits 02:22-04:57

The next thing we need to discuss is configuring user limits. Understand that you can configure limits for how many times a user may log in, how much CPU time they use, how much memory they can use, and so on. We configure these limits in the '/etc/security/limits.conf' file. The syntax for this file is shown here. First, we specify the domain. The domain, as noted here, can be a user, or it could be a group.

If you want to use a group, you have to put this '@' sign in front of the group name to indicate that it's a group, or you can use a wild card-- listed here--to apply it to everybody. Scroll down a little bit so we can see more.

Next, we specify the type. As noted here, the type can have two different values. We can either specify a hard limit that can never be exceeded, or we can specify a soft limit that can be exceeded, but just temporarily. Then we specify the item. This is the particular thing that's going to be limited. As you can see down here, we have lots of different options for how we can limit what the item can be.

We can specify core to limit the size of the core dump files. We can specify data to configure a maximum data size and memory for the user's programs. We can specify fsize to restrict the maximum file size. We can specify nofile. We can specify the maximum number of open files. We can specify rss to set the maximum resident set size and memory. We can specify stack to set the maximum stack size. We can specify cpu and set the amount of CPU time that can be used by a single process in minutes. We can specify nproc to specify the number of concurrent processes that will be allowed. Or we can come down here and specify max logins to specify the maximum number of simultaneous logins that we allow for this user. We can also specify priority if we want to, to specify the priority to run user processes with, for this particular user account. Once we specify the item, we scroll back here, and then we specify the value for that item. This is the limit that we're going to configure.

With this in mind, let's go down here, and let's create a new limit. We're going to configure a limit for our rmckay user. I'll enter 'rmckay' for our domain. Next, we want to specify a hard limit, and the item we want to limit is our CPU time. This is the maximum amount of CPU time that a single process run by this user can consume. We must specify how much that is. We do that in minutes. We'll specify 10 minutes. Lets save this by typing "wq!" and hitting Enter. To apply the change, we have to reboot the system.

### ulimit Command 04:57-07:01

The last thing we're going to look at the in this demonstration is the ulimit command. To be honest, I don't really care much for the ulimit command. In my experience, it's not as useful as the limits.conf file that we just looked at. The ulimit command does allow you to configure limits on system resources on a per-user basis, much like we did in the limits.conf file. However, be aware that any limits that you configure with ulimit will only affect programs that are launched from within the shell prompt. If, on the other hand, the user was to come over here and launch a graphical application on the desktop, then the limits you specify with ulimit aren't applied. That's why I don't really care for it.

The syntax for ulimit is to enter 'ulimit' followed by the options you want to use and then the limit that you want to specify. There are many different limits you can configure with ulimit. Take a look at the ulimit man page to see a full list of what you can do. For our purposes today, let's just run 'ulimit -a' to, first of all, view the current limits for my user account. You can see what they are right here.

You can also use ulimit to set a limit. Let's set a basic limit. Let's suppose we want to set a soft limit of 100 concurrent processes for my user account. To do this, we would enter' ulimit-s' to set a soft limit. If we wanted to, we could use -h to set a hard limit. Then we have to specify which limit we want to use. We'll use the '-u' option to set the maximum number of processes available to the user. How did I know that that's the right option to use? I looked at the man page. That's what you should do as well. Then we must set that to a specific value. Let's enter '100'. My user account can only have a maximum of 100 concurrent processes. Enter, and the limit is applied.

If we run 'ulimit -a' again, we see that my max user processes have dropped from 7,084 down to 100, which, depending on how the system is being used, would not be anywhere near enough. That's essentially how you use ulimit. Basically, you use ulimit to constrain what users can do so you don't end up with one user hogging all the system resources and not allowing other users on the system to access them.

### Summary 07:01-07:18

That's it for this demonstration. In this demo, we talked about how to set up user restrictions on limits. First, we looked at password aging. We looked at login limits. Then we ended this demonstration by looking at the ulimit command.

## 6.7.12 Linux User Security and Restriction Facts

This lesson covers the following topics:

+ User security
+ User security commands

### User Security

When considering user security, keep the following in mind:

<ul>
   <li>
    Users should be trained to use secure passwords. Secure passwords use numbers and letters and are more than 
	seven characters in
    length.
   </li>
   <li>
    Passwords should expire periodically but not too often.
   </li>
   <li>
    Administrators can limit the resources that the user can access.
   </li>
  </ul>

### User Security Commands

The following table describes Linux commands used to promote user security and restrictions:

<table>
   <thead>
    <tr><th scope="col" class="fw-bold">
     Command
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     <b class="fw-bold">
      chage
     </b>
    </td>
    <td>
     Set user passwords to expire. Be aware of the following options:
     <ul>
      <li>
       <b class="fw-bold">
        -M
       </b>
       sets the maximum number of days before the password expires.
      </li>
      <li>
       <b class="fw-bold">
        -W
       </b>
       sets the number of days before the password expires that a warning message displays.
      </li>
      <li>
       <b class="fw-bold">
        -m
       </b>
       sets the minimum number of days that must pass after a password has been changed before a user can change
          the password again.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     <b class="fw-bold">
      ulimit
     </b>
    </td>
    <td>
     Limits computer resources used for applications launched from the shell. Limits can be hard or soft limits. Soft limits can
        be temporarily exceeded up to the hard limit setting. Users can modify soft limits, but only the root user can modify hard
        limits. Options include:
     <ul>
      <li>
       <b class="fw-bold">
        -c
       </b>
       limits the size of a core dump file. The value is in blocks.
      </li>
      <li>
       <b class="fw-bold">
        -f
       </b>
       limits the file size of files created using the shell session. The value is in blocks.
      </li>
      <li>
       <b class="fw-bold">
        -n
       </b>
       limits the maximum number of files that can be open.
      </li>
      <li>
       <b class="fw-bold">
        -t
       </b>
       limits the amount of CPU time a process can use. This is set in seconds.
      </li>
      <li>
       <b class="fw-bold">
        -u
       </b>
       limits the number of concurrent processes a user can run.
      </li>
      <li>
       <b class="fw-bold">
        -d
       </b>
       limits the maximum amount of memory a process can use. The value is in kilobytes.
      </li>
      <li>
       <b class="fw-bold">
        -H
       </b>
       sets a hard resource limit.
      </li>
      <li>
       <b class="fw-bold">
        -S
       </b>
       sets a soft resource limit.
      </li>
      <li>
       <b class="fw-bold">
        -a
       </b>
       displays current limits. The default shows soft limits.
      </li>
     </ul>
    </td>
   </tr>
  </tbody></table>