---
lang: zh-CN
title: Section 6.10 Network Authentication
description: some description
---

As you study this section, answer the following questions:

<ul>
    <li>
     In the challenge/response process, what information is exchanged over the network during logon?
    </li>
    <li>
     What is included in a digital certificate?
    </li>
    <li>
     What is PKI?
    </li>
    <li>
     Which tool can manage authentication credentials on Windows hosts?
    </li>
   </ul>

In this section, you will learn to:

<ul>
    <li>
     Control the authentication method.
    </li>
    <li>
     Configure Kerberos policy settings.
    </li>
    <li>
     Manage credentials.
    </li>
   </ul>
   
The key terms for this section include:

<table class="terms">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Term
    </th>
    <th scope="col" class="fw-bold">
     Definition
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Authentication
    </td>
    <td>
     Authentication is the process of validating user credentials that prove user identity.
    </td>
   </tr>
  </tbody></table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Exam
    </th>
    <th scope="col" class="fw-bold">
     Objective
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     TestOut Security Pro
    </td>
    <td>
     1.0 Identity Management and Authentication
     <blockquote>
      1.2 Harden Authentication
     </blockquote>
    </td>
   </tr>
   <tr>
    <td>
     CompTIA Security+ SY0-601
    </td>
    <td>
     3.8 Given a scenario, implement authentication and authorization solutions.
     <ul>
      <li>
       Authentication
       <ul>
        <li>
         EAP
        </li>
        <li>
         802.1X
        </li>
        <li>
         Single sign-on (SSO)
        </li>
        <li>
         Security Assertions Markup Language (SAML)
        </li>
        <li>
         OAuth
        </li>
        <li>
         OpenID
        </li>
        <li>
         Kerberos
        </li>
       </ul>
      </li>
     </ul>
    </td>
   </tr>
  </tbody></table>

## 6.10.1 Network Authentication Protocols

### Network Authentication Protocols 00:00-00:59

An authentication protocol is the method used to exchange authentication credentials.

It defines the type of credentials that are accepted as identification.

For example, suppose we have a computer that wants to connect to a server that requires authentication. In this situation, the server is sometimes called the authenticator because it accepts and verifies device credentials.

One simple way to authenticate is for the authenticator to ask, "Who are you, and what's your password?"

Early authentication protocols were nothing more than this. And in most cases, the password wasn't even encrypted. It was sent in plain text.

As you can imagine, this isn't a very secure authentication method. Someone could intercept this conversation, capture the username and password, and then use those credentials to gain access to the server.

Thankfully, now there are various authentication protocols that strengthen the authentication process. Before we jump into explaining the different protocols, let's look at some of the components that make network authentication possible.

### Challenge Response Authentication 00:59-02:54

The first component we'll look at is the challenge—"response authentication model.

When a client wants to authenticate to a network that employs a challenge—"response authentication model, a couple of things happen.

First, the server sends a challenge to the client. The client takes this challenge and, using a secret algorithm known to both the client and the server, sends a response message. If the response message is what the server expects, the client is verified and authenticated to the network.

For example, suppose we have a client that is trying to authenticate to a server. The client sends a login request to the server. When the server receives this login request, it sends a challenge string back to the client.

Now, both the client and the server know the password; however, we don't want to transmit the password across the network, as it could be intercepted. Instead, the client uses the password to encrypt a challenge response as part of the encryption material.

The client will send that challenge response back to the server, and the server will verify it.

If the client used the correct password as part of the encryption, the server then uses the shared password to determine whether the correct password was supplied by the client. If it was, then the server allows the client on the network. If the wrong password was used in the response message, then the client is denied access.

With a challenge response authentication model, it's also possible for the client to verify the identity of the server. This is called mutual authentication.

When mutual authentication is used with a challenge response authentication protocol, both the server and the client verify each other.

First, the server sends a challenge message to the client. The client then computes the message with an algorithm that both the client and server know. If the response is what the server expects, the server sends a response back to the client using the known secret algorithm.

If the response is what the client expects, then the client has verified the server's identity.

Mutual authentication allows both the client and the server to verify each other. This helps protect the client from being redirected to a malicious server.

### Symmetric-Key Cryptography 02:54-03:51

Our second component is symmetric-key cryptography. With symmetric key cryptography, a single key is used to both encrypt and decrypt the same message.

This is how it works.

Both the client and the server know the user's password, and the password is hashed to create a secret key.

Since both the client and the server have this information, this key is sometimes called the shared secret.

One party can prove knowledge of this shared secret key by encrypting a piece of information and sending it to the other party. The other party, having the same secret symmetric key, can use that key to decrypt the information.

The same key is used to encrypt and decrypt data.

There's also an encryption method called asymmetric-key cryptography. We won't go into any detail on that right now, but just know that asymmetric-key cryptography uses two different keys instead of two identical keys.

Now that we've looked at some of the components of network authentication, let's look at some of the different network authentication protocols you'll encounter.

### Kerberos 03:51-05:04

The first protocol is Kerberos. Kerberos is a very secure open-source authentication protocol developed by MIT. They created it so their computers could prove their identities on non-secure networks.

Kerberos has been used by UNIX and Linux and has been the default authentication protocol used in Microsoft Active Directory environments since Windows 2000.

Kerberos provides functions such as single sign-on capability and mutual authentication, and it can authenticate using both symmetric key cryptography and asymmetric key cryptography.

Kerberos also performs both authentication and authorization for resources and uses tickets to identify authenticated users or devices.

First, Kerberos uses an authentication server. The authentication server is used to authenticate users and computers.

Second, Kerberos uses a service server. The service server holds resources, such as a shared printer, a file, or some kind of network resource, that has controlled access.

The third component is called a ticket granting server. This server grants authorization tickets. In some implementations, the authentication server and ticket granting server are combined into a single entity.

### EAP 05:04-05:23

The second authentication method is the Extensible Authorization Protocol, or EAP. EAP really isn't an authentication protocol by itself, it's more of a method for identifying which authentication protocol to use.

After two devices using EAP agree to perform authentication, they must then agree on which protocol to use.

### 802.1x 05:23-06:41

Another authentication protocol is 802.1X. 802.1X authentication uses a connection point along with some form of authentication server, typically a RADIUS server.

Let's see how this works.

In this example, we have a connection point, which is usually a switch or a wireless access point. This access point is also configured to only allow authenticated traffic. This access point is also connected to the authentication server, or RADIUS server.

When a client connects to the access point, it's asked to provide authentication credentials. The client sends these credentials to the access point, which passes them to the authentication server. The authentication server the uses a database to validate these credentials. If the credentials match, the access point is notified that the client has authenticated successfully, and the client is then allowed network access.

802.1X authentication is an extension of the extensible authentication protocol and uses EAP. So, when the client computer authenticates to the authentication server, it might do that with usernames and passwords, or it might use certificates.

The authentication server might even use a smart card or some kind of biometric authentication.

In other words, 802.1X uses EAP to negotiate the specific type of credentials, or the protocol, that is used to exchange information.

### LDAP 06:41-07:21

The last network authentication protocol we'll look at is LDAP. LDAP stands for Lightweight Directory Access Protocol and is a protocol for accessing an LDAP-compliant directory service. It's not a directory service itself.

There are many different types of directory services used in various network implementations. For example, there's Microsoft's Active Directory, Open LDAP on Linux systems, and eDirectory from NetIQ. Although each of these directory services are different vendors, they are all adhere to the LDAP specifications.

The idea behind the LDAP is to provide a standardized open protocol that applications can use to access information stored in any LDAP-compliant directory.

### Summary 07:21-07:46

That's it for this lesson.

In this lesson we talked about some of the network authentication protocols you might encounter as a security professional.

We started by talking about the challenge-response authentication method.

Then we looked at the difference between symmetric and asymmetric encryption.

And we finished by looking at the Kerberos, EAP, 802.1x, and LDAP network authentication protocols.

## 6.10.2 Network Authentication Facts

This lesson covers the following topics:

- Network authentication overview
- Network authentication protocols

### Network Authentication Overview

Authentication is the process of validating user credentials that prove user identity. Authentication is typically the first step in connecting to a network. Following successful authentication, access controls can be implemented to allow or deny access to network resources.

A simple form of authentication sends a username and password to an authentication server. If the password is sent in cleartext, the authentication credentials can be intercepted and used to impersonate an authorized user. One method of protecting login credentials is by using a challenge/response mechanism (also called a three-way handshake). Using this method, both the authentication server and the authenticator are configured with a common shared secret. This shared secret is usually a password associated with a user account. The process is:

<ol type="1">
   <li>
    The authentication server sends a challenge string to the authenticator.
   </li>
   <li>
    The authenticator uses the shared secret to hash the challenge string and returns the user account name and the hashed
      value to the authentication server.
   </li>
   <li>
    The authentication server also uses its shared secret value to hash the challenge string. If the two hashed values match,
      the authentication server assumes that the authenticator also knows the shared secret.
   </li>
  </ol>

With the challenge/response method, the password is never sent through the network; only the hashed challenge string is exchanged. Be aware that the hashed challenge string is not an encrypted form of the password.

### Network Authentication Protocols

An authentication protocol identifies how credentials are submitted, protected during transmission, and validated. Instead of a simple username and password, some authentication protocols require certificates and digital signatures for proof of identity.

<ul>
   <li>
    A certificate is a digital document that identifies a user or a computer. The certificate includes a subject name, which
      is the name of a user or a computer.
   </li>
   <li>
    Certificates are obtained from a public key infrastructure (PKI). A PKI is a collection of hardware, software, policies,
      and organizations that create, issue, and manage digital certificates.
   </li>
   <li>
    A PKI is made up of certificate authorities (CAs), also called certification authorities. A CA:
    <ul>
     <li>
      Accepts certificate requests
     </li>
     <li>
      Verifies the information provided by the requester
     </li>
     <li>
      Creates and issues the certificate to the requester
     </li>
     <li>
      Revokes certificates, which invalidates them
     </li>
     <li>
      Publishes a list of revoked certificates known as the certificate revocation list (CRL)
     </li>
    </ul>
   </li>
   <li>
    You can obtain certificates from a public CA such as DigiCert or install your own PKI and CAs to issue certificates to
      users and computers in your organization.
   </li>
   <li>
    Computers accept any certificate issued by a trusted CA as valid. By default, most computers trust well-known public CAs.
      If you configure your own PKI, you need to configure each computer in your organization to trust your own CAs.
   </li>
   <li>
    A digital signature is a digital document that is altered so that it could have come only from the subject identified in
      the certificate. A certificate obtained from a PKI is signed by the CA that issued the certificate. The digital signature of
      the issuing CA is included in the certificate.
   </li>
   <li>
    A computer that receives a certificate verifies the issuing CA's signature. If the CA is trusted, the computer will
      accept the user or computer's identity.
   </li>
  </ul>

The following table describes various authentication methods used for network authentication. Many of these use some form of challenge/response mechanism.

<table>
   <thead>
    <tr><th scope="col" class="fw-bold">
     Protocol
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Kerberos
    </td>
    <td>
     Kerberos is used for both authentication and authorization services. It is the default authentication
        method used by computers that are a part of an Active Directory domain. Kerberos grants tickets, also called a secure
        tokens, to authenticated users and to authorized resources. The process of using tickets to validate permissions is called
        delegated authentication. Kerberos uses the following components:
     <ul>
      <li>
       An authentication server (AS) accepts and processes authentication requests.
      </li>
      <li>
       A service server (SS) is a server that provides or holds network resources.
      </li>
      <li>
       A ticket-granting server (TGS) grants tickets that are valid for specific resources on specific servers.
      </li>
      <li>
       The authentication server and ticket-granting server are often combined into a single entity known as the Key
          Distribution Center (KDC).
      </li>
     </ul>
     Kerberos uses the following process:
     <ol type="1">
      <li>
       The client sends an authentication request to the authentication server.
      </li>
      <li>
       The authentication server validates the user identity and grants a ticket-granting ticket (TGT). The TGT validates
          the user identity and is good for a specific ticket-granting server.
      </li>
      <li>
       When the client needs to access a resource, it submits its TGT to the TGS. The TGS validates that the user is allowed
          access and issues a client-to-server ticket.
      </li>
      <li>
       The client connects to the service server and submits the client-to-server ticket as proof of access.
      </li>
      <li>
       The SS accepts the ticket and allows access.
      </li>
     </ol>
    </td>
   </tr>
   <tr>
    <td>
     Open Authorization
     <br>
     (OAuth)
    </td>
    <td>
     Open Authorization (OAuth) is an open standard for token-based authentication and authorization on the
        internet. It allows access tokens to be issued to third-party clients by an authorization server with the approval of the
        resource owner. The third party uses the access token to access the protected resources hosted by the resource server. This
        mechanism is used by companies like Google, Facebook, Microsoft, and Twitter, to permit users to share information about
        their accounts with third-party applications or websites.
     <p>
      OAuth specifies a process for resource owners to authorize third-party access to their server resources without sharing
        their credentials. It is designed to work with the Hypertext Transfer Protocol (HTTP). OAuth is a service that is
        complementary to and distinct from OpenID.
     </p>
    </td>
   </tr>
   <tr>
    <td>
     OpenID
    </td>
    <td>
     OpenID is an open standard and decentralized authentication protocol. It allows users to be
        authenticated by co-operating sites using a third-party service and allowing users to log in to multiple unrelated websites
        without having a separate identity and password for each. Users create accounts by selecting an OpenID identity provider
        and using those accounts to sign on to any website that accepts OpenID authentication.
     <p>
      The OpenID protocol does not rely on a central authority to authenticate a user's identity. Because neither services
        nor the OpenID standard mandates how to authenticate users, authentication methods range from passwords to smart cards and
        biometrics.
     </p>
    </td>
   </tr>
   <tr>
    <td>
     Extensible Authentication Protocol
     <br>
     (EAP)
    </td>
    <td>
     EAP allows the client and server to negotiate the characteristics of authentication.
     <ul>
      <li>
       An EAP authentication scheme is called an
       <i class="fs-italicize">
        EAP type
       </i>
       . Both the client and authenticator have to support the same EAP type for authentication to function.
      </li>
      <li>
       When a connection is established, the client and server negotiate the authentication type that will be used based on
          the allowed or required authentication types configured on each device.
      </li>
      <li>
       The submission of authentication credentials occurs based on the rules defined by the authentication type.
      </li>
      <li>
       EAP is used to allow authentication with smart cards, biometrics, and certificate-based authentication.
      </li>
     </ul>
     Other versions of EAP include:
     <ul>
      <li>
       Protected Extensible Authentication Protocol (PEAP) is a more secure version of EAP. It provides authentication to a
          WLAN that supports 801.1x. PEAP uses a public key over TLS.
      </li>
      <li>
       EAP-FAST, which is also known as flexible authentication via secure tunneling. This version performs session
          authentication in wireless networks and point-to-point connections.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     802.1x
    </td>
    <td>
     802.1x is an authentication method used on a LAN to allow or deny access based on a port or connection
        to the network.
     <ul>
      <li>
       802.1x is used for port authentication on switches and authentication to wireless access points.
      </li>
      <li>
       802.1x requires an authentication server for validating user credentials. This server is typically a RADIUS
          server.
      </li>
      <li>
       Authentication credentials are passed from the client, through the access point, to the authentication server.
      </li>
      <li>
       The access point enables or disables traffic on the port based on the authentication status of the user.
      </li>
      <li>
       Authenticated users are allowed full access to the network; unauthenticated users have access to only the RADIUS
          server.
      </li>
     </ul>
     802.1x is based on EAP and can use a variety of methods for authentication, such as usernames and passwords;
        certificates; or smart cards.
    </td>
   </tr>
  </tbody></table>

The Lightweight Directory Access Protocol (LDAP) is a lightweight protocol that allows users and applications to read from and write to an LDAP-compliant directory service, such as Active Directory, eDirectory, and OpenLDAP. The LDAP client must bind (authenticate) to the directory service before reading/writing to the database. The LDAP server can also authenticate to the client. This is known as mutual authentication.

LDAP supports the following authentication modes when binding to a directory service:

<table>
   <thead>
    <tr><th scope="col" class="fw-bold">
     Mode
    </th>
    <th scope="col" class="fw-bold">
     Description
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Anonymous
    </td>
    <td>
     Only a user name (no password) is required to authenticate.
    </td>
   </tr>
   <tr>
    <td>
     Simple
    </td>
    <td>
     A username and password are required. Normally, the username and password are passed in cleartext. LDAP
        uses ports 389 and 636 by default.
    </td>
   </tr>
   <tr>
    <td>
     Simple Authentication and
     <br>
     Security Layer (SASL)
    </td>
    <td>
     SASL is an extensible mechanism for protecting authentication.
    </td>
   </tr>
  </tbody></table>

## 6.10.3 LDAP Authentication

### LDAP Authentication 00:00-02:09

In this lesson, we'll discuss the Lightweight Directory Access Protocol authentication, or LDAP.

LDAP is an open-source protocol used to communicate with network directories. It is a lightweight, fast protocol that runs over TCP/IP. That makes it ideal for internet-based access requests. Because LDAP is an open protocol, most applications can access a desired server regardless of the directory service being used to manage authentication. LDAP traffic is in cleartext by default, but LDAP can run using SSL or some type of transport-level security.

So, how exactly does LDAP work? Let's say we have a client who is trying to access network resources. The network's server has been configured with Active Directory.

Active Directory includes a database with details about authorized network user's information including usernames, passwords, and groups. It also stores information about various network resources including the level of access each user has to that resource.

To be compliant with the LDAP protocol, data must be stored using a standard method. For example, each database entry must be an object with specific attributes. This structure helps to ensure that a directory can be easily accessed and the desired information can be found.

To obtain access to the network, Active Directory and the client must speak the same language. This is where LDAP comes in. The client sends a request with required credentials to Active Directory. When Active Directory receives the request and the credentials, it compares them the information to the database. If the information matches, the request is authorized. The client is then connected to the appropriate network resources.

You must set up LDAP to authenticate credentials against the information stored in directory services. A bind method sets the authentication state for an LDAP session. You can use one of two options to perform the authentication.

Simple Authentication uses name and password authentication, unauthenticated authentication, or anonymous authentication. Most of the time, a name and a password create the bind request that's sent to the server.

### SASL Authentication 02:09-02:41

Simple Authentication and Security Layer authentication, or SASL, uses a different authentication service such as Kerberos to bind to the LDAP server. The LDAP server then uses this authentication service. This method provides additional security because the authentication method is separated from the application protocols.

As you can see, while directory services provide security specific to your network, LDAP provides a method for communication with remote clients. LDAP and directory services work hand in hand to keep your network secure.

### Summary 02:41-03:00

That's it for this lesson. In this video, we discussed the Lightweight Directory Access Protocol. We discussed what it is and how it works. We also covered the two authentication methods, simple authentication and SASL authentication.

## 6.10.4 Kerberos Authentication

### Kerberos Authentication 00:00-00:12

In this lesson, we're going to look at the Kerberos authentication process. To begin with, let's look at our example network.

### Kerberos Configuration 00:12-00:41

On the left we have a client that wants to access some accounting documents on the file server, over here.

To access that resource, the client must authenticate to the network and prove they have the appropriate permissions to access this data. With Kerberos, this is done by requesting a ticket. The first step is to contact the Key Distribution Center, or KDC.

The KDC is actually split into two different servers— an authentication server and a ticket granting server.

### Authentication Server 00:41-01:17

The first step in the authentication process is to talk to the authentication server and request authentication.

The authentication server will send two things back to the client.

It sends a session key to access the ticket granting server called a TGS session key. That session key is encrypted with the shared secret key, which is based on the hash of the user's password that both the user and the authentication server know. So only that user, with the copy of their shared secret key based on their own password, should be able to decrypt the TGS session key.

### Ticket Granting Server (TGS) 01:17-03:10

The authentication server also sends back a Ticket Granting Ticket, a TGT.

The TGT grants them the ability to ask for more tickets.

After that, the client will contact the TGS and send two pieces of information.

It'll send a copy of its ticket granting ticket to the ticket granting server and ask for more tickets. It also sends the TGS session key. A session key is used between two entities to communicate secure information just for that particular session, so the client has a secure channel with the ticket granting server.

The ticket granting server will send two things back to the client. First, it sends a ticket that can be used to access the file server; this ticket is encrypted using a secret key that only the file server and the KDC know. Second, it sends a file server session key to the client. When the client receives these two items, it sends them to the file server. It'll send the file server ticket and the file server session key.

Since the ticket was originally encrypted with the file server's secret key, the file server knows that if it can decrypt the ticket, it originated from the KDC, and the file server can trust that the client has appropriate permissions to access files. The file server can also decrypt the session key. And if the file server can decrypt the session key, it trusts the client.

In this example, the KDC is the trusted third party that both the client and the file server can trust. It enables them to say, "Even though I don't really trust this client, I do trust the KDC. So, if a client comes to me with a ticket and session key from the KDC, I have no problem giving them access."

Finally, the file server will send a final message to the client, which is a message encrypted with the file server session key. If the client can decrypt that message, they can start exchanging information.

### Encrypted Messages 03:10-03:26

The great thing about this entire communication and authentication process is that all the messages—"the handshakes—"are encrypted.

So, even if an attacker were to be on this network capturing traffic, they wouldn't be able to obtain any useful information—"it's all encrypted.

### The Kerberos Theme Park 03:26-05:02

If this is a bit confusing, try thinking about it like this.

Let's say you decide to spend your Saturday at the happiest place on Earth—"the Kerberos theme park. Here's a map of the theme park. Let's put some labels on each part of this theme park. Now, let's pair them with their network analogs. The rides are like individual servers, the front gate is the authentication server, and the ride ticket booth is like the ticket granting server.

In order to get into the park, you need to go to the ticket booth and purchase a park ticket. Think of the ticket booth as the authentication server that hands out ticket granting tickets. This ticket doesn't actually let you ride each of these rides. What it does instead is allow you to obtain individual tickets for each ride at the ride ticket booth.

So, if you want to ride the stomach-churning, triple-loop, double-corkscrew roller coaster, you have to go to the ride ticket booth and show them your entry ticket. Because the entry ticket was given to you by the front gate—"the authentication server—"they know that you are allowed to be in the park and ride the rides. So they give you a ticket for the stomach-churning, triple-loop, double-corkscrew roller coaster.

With your ride ticket in hand, you can go to the ride and show it to the ride attendant. Because the attendant trusts the front gate, they know you are allowed to ride the ride and let you in.

And remember, these tickets are stamped with a date. So, if you were to try to come back to this park the next day and use the same ticket, you would be rejected—"the ticket is only valid for the day it was issued. This is the same with tickets granted through Kerberos. They are time stamped and only valid for that particular session time.

### Summary 05:02-05:20

So, that's how the Kerberos authentication process works.

Remember, Kerberos uses a trusted third party, the KDC, to create tickets and session keys that can be used to authenticate clients to various servers in the network.

## 6.10.5 Controlling the Authentication Method

### Authentication Method Control 00:00-00:16

In this demonstration, we'll talk about controlling the authentication method on a Windows domain controller. The first thing we'll do in this demonstration is look at the Kerberos Group Policy settings.

### Default Kerberos Policy Settings 00:16-02:08

Kerberos account policy settings are set in the Default Domain Policy. They're set automatically when Active Directory is initially installed. Let's take a look at what they are. We'll go to Tools > Group Policy Management and we'll edit the Default Domain Policy. Remember that the Default Domain Policy is applied to the domain itself. Therefore, it applies to all objects within the entire domain, no matter what organizational unit they reside in. Let's click Edit.

To view Kerberos Group Policy settings, let's go to Computer Configuration > Policies > Windows Settings > Security Settings > Account Policies > Kerberos Policy.

Here, you can see the default Kerberos Policy settings. We have Enforce user logon restrictions, which is enabled. The Maximum lifetime for a service ticket is 600 minutes. Maximum lifetime for user ticket is 10 hours. The Maximum lifetime for user ticket renewal is 7 days and the Maximum tolerance for computer clock synchronization is 5 minutes.

This setting here is important. It sets the maximum tolerance for clock synchronization. By default, if the client workstation's clock and the domain controller's clock are more than 5 minutes out of sync, the client will not be allowed to log in to the domain. Therefore, you need to make sure that the client workstation clocks are synced up with your domain controllers.

By default, the clocks on Windows hosts automatically synchronize themselves to the first domain controller in each domain. This first domain controller is called the PDC emulator.

These default Kerberos settings, as well as the time synchronization restriction, are important because they're designed to help prevent replay attacks. That's where an attacker might capture a Kerberos ticket going across the wire and then attempt to replay that ticket, pretending that it's the original client. If successful, the attacker could gain access to confidential information.

### Default Domain Controllers Policy 02:08-02:48

In addition to Kerberos policy settings, there are other security options that you can set as well. These are not configured in the Default Domain Policy. They are instead configured in the Default Domain Controllers Policy. This is one of the policies that is automatically setup and configured for you when Active Directory is initially installed. Let's edit this policy.

Let's go to Computer Configuration > Policies > Windows Settings > Security Settings > Local Policies > Security Options. There are many settings here you can configure if you need to. However, there are several default settings, already set for you.

### Security Options 02:48-03:48

One of the settings you should be aware of is under Interactive logon. It's named Don't display last signed-in policy.

As you can see by enabling this policy, we can choose to either show or hide the last signed on user. This could be a good security method that would prohibit anyone with access to the computer from obtaining a user account name.

If you go to the Explain tab, it will give you a description related to this policy. We'll leave this policy as is, so let's click Cancel.

In addition, another policy you could look at is the Interactive logon, Number of previous logons to cache. This controls how many previous logins are stored on a workstation for a domain. If you define this policy, it asks how many previous logins you want to store on this device.

This is most useful with laptops that may be authenticating users that are not currently connected to the domain. By default, Windows caches 10 users so the last 10 users who logged on to the laptop should be able to authenticate locally if the laptop was disconnected from the domain. Let's click Cancel.

### KDC Service 03:48-04:34

Now, the last thing we'll look at is the KDC service. If you have authentication problems on your domain controller, one thing to check is the status of the KDC service. If it isn't running, then no tickets are being issued and you're going to have problems. Let's go to Tools and scroll down to Services.

Scroll down to the Ks. We should see the Kerberos Key Distribution Center (KDC) settings. Double-click it. This service is composed of two sub-components that are used by Kerberos. It provides your authentication server and your ticket granting server. They're both combined together to form the KDC. If you have authentication problems, you may want to check and make sure that the status of the KDC is Running. If it's not, you can start the service manually, if necessary.

### Summary 04:34-05:11

That's it for this demonstration. In this demo, we talked about controlling the authentication method for Windows domain controllers. We first look at various Kerberos Group Policy settings. We emphasized the importance of making sure that the client and server are synchronized as far as system time is concerned. We then looked at several security option settings that can be configured in Group Policy such as the Don't display last signed in policy.

Then finally, we looked at the KDC service. We emphasized the fact that if the service has not started for some reason, authentication will not work in the domain.

## 6.10.7 Credential Management

### Credential Management 00:00-00:42

In this demonstration, we're going to look at how you can use the Credential Manager in Windows to save authentication credentials and make accessing network resources much easier. Let's start by accessing a network server.

I'll pull up File Explorer and enter a UNC path to our server. When I do that, I get this Credentials box. If my current credentials had existed on the other server, if I were logged into the domain with the associated accounts, I'd automatically be connected. In this case, I'm in a workgroup environment, and the server has different credentials that I need to use to attach. I'll go ahead and enter those now.

### Save Credentials 00:42-01:23

Another thing I'm going to do is click on Remember my credentials so that it remembers me later. OK. We can see that I have access to those shared folders. When I log out and back in, I'll automatically connect to that resource again since I saved my credentials. Here, I'll show you. Log out and log back in. There we are.

I'll pull up the File Explorer again and re-enter that IP address. You'll notice I've gone there automatically. How come? If you go to the Credential Manager in Windows, you'll see that it's saved our credentials.

### Credential Manager File 01:23-03:33

Let's go ahead and just go through the Control Panel. If I pull up the Control Panel and I go to User Accounts, then, under there, you can see the Credential Manager.

There are two different parts to the Credential Manager. You have your web credentials--we'll talk about that in a minute--and you have your Windows credentials over here. If you click on Windows Credentials, you can see that it's saved your Windows credentials attached to this network resource. If we wanted to, we could click into them and edit them. Maybe we'd use a different account to connect. We could also remove the credentials. And sometimes it's handy to be able to back them up in case you have a lot of different credentials saved on your local machine.

Let's go ahead and go through that process right now. We'll just back up the one credential we have, and we'll save it onto the desktop for now. We'll give it a name. Then, as we click Next, you'll notice that it says we need to press CTRL+Alt+Delete to continue to back up to the secure desktop--that is, we don't want any malware or anything else to have access to this transaction as we're putting that sensitive information onto our desktop.

I'm going to go ahead and press CTRL+Alt+Delete, and then you need to enter a password to protect those credentials so that when you restore, you enter this new password.

I've entered that now, and it says okay, great, it was successful. It'll save that data to the desktop. You can see mycreds.crd right there. Let's go ahead and remove these credentials—and now, let's restore them. It's a similar process where you select the credentials that you saved, and then you simply type in the password after entering Secure Desktop. It says that they've been restored now. It looks like we just need to refresh Credential Manager to see the restored credentials.

Let's go back to these web credentials now. Since Windows 8, Microsoft has the ability to save credentials that you might use on websites and to manage them within this Credential Manager as well.

### Credential Manager File Location 03:33-03:59

If we pull up Internet Explorer, we can see where those credentials are saved. If we come up here, to Settings, and we go down to Internet Options, over to the Content tab, and under Autocomplete Settings, you can see that we can manage passwords for usernames and passwords that are saved on forms. If we click Manage Passwords, guess where we go? Right back to Credential Manager. You can use that to save and back up those credentials on Windows 10.

### Summary 03:59-04:19

That's it for this demonstration. In this demo, we looked at Credential Manager on Windows 10, and we talked about how it makes accessing network resources much easier when you're not on a domain. We also talked about how Credential Manager can be used to manage web credentials.

## 6.10.8 Credential Management Facts

This lesson covers the following topics:

- Credential management systems
- Authentication management tools

### Credential Management Systems

It's not uncommon for an organization's network to evolve over time to include many systems that use their own exclusive authentication mechanisms. In this situation, users must use several sets of authentication credentials to access the services on these systems. The danger associated with this situation is that users may begin to write down passwords or save them in a file. This represents a significant security risk.

To prevent this from happening, consider using a credential management system. A credential management system securely stores a user's authentication credentials for multiple systems, including servers and websites.

### Authentication Management Tools

The following tools can be used to manage authentication credentials:

<table>
   <thead>
    <tr><th scope="col" class="fw-bold">
     Operating System
    </th>
    <th scope="col" class="fw-bold">
     Authentication Management Tool
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Windows
    </td>
    <td>
     On Windows hosts, you can use Credential Manager to manage authentication credentials. Credential
        Manager stores account credentials for network resources, such as file servers and websites. Credential Manager:
     <ul>
      <li>
       Saves authentication credentials in the Windows Vault.
      </li>
      <li>
       Uses saved account credentials when the user accesses a particular network resource.
      </li>
      <li>
       Stores account credentials from Windows Explorer, Internet Explorer, or the Remote Desktop client.
      </li>
      <li>
       Allows account credentials to be added to the vault using one of the following methods:
       <ul>
        <li>
         The Remember My Credentials link in the Windows Security dialog allows the credentials to be added when accessing
            the resource.
        </li>
        <li>
         The Add a Windows credential link allows the credentials to be added without accessing the resource. When using
            this option, you must enter the internet or network address of the resource.
        </li>
       </ul>
      </li>
      <li>
       Allows saved credentials to be edited or deleted.
      </li>
      <li>
       Does not display passwords for saved credentials.
      </li>
     </ul>
    </td>
   </tr>
   <tr>
    <td>
     Linux
    </td>
    <td>
     There are a variety of credential management systems available for Linux systems. One commonly used
        package is KWalletManager, which stores account credentials for network resources, such as file servers and websites.
        KWalletManager:
     <ul>
      <li>
       Saves the account credentials in a secure "wallet."
      </li>
      <li>
       Stores authentication credentials used to connect to network servers as well as secure websites.
      </li>
      <li>
       Uses saved account credentials when the user accesses a particular network resource.
      </li>
      <li>
       Offers two encryption options, Blowfish and GPG, for protecting credentials stored in the wallet.
      </li>
      <li>
       Does not display passwords for saved credentials.
      </li>
      <li>
       Uses KDE Wallet Manager application to add, remove, or modify saved credentials. KDE Wallet Manager can also back up
          the contents of the wallet by exporting it to an encrypted .kwl file.
      </li>
     </ul>
    </td>
   </tr>
  </tbody></table>
