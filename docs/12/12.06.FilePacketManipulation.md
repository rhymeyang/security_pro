---
lang: zh-CN
title: Section 12.6 File and Packet Manipulation
description: some description
---

As you study this section, answer the following questions:

<ul>
    <li>
     What tools can you use to keep your network safe and minimize potential risks?
    </li>
    <li>
     How can PowerShell and Python be useful to an administrator?
    </li>
    <li>
     What are some of the most common Linux utilities used by both hackers and security analysts/system administrators?
    </li>
</ul>

In this section, you will learn to:

<ul>
    <li>
     Use TCPDump to capture packet data.
    </li>
    <li>
     Use Wireshark to capture network protocol information.
    </li>
    <li>
     Use TCPReplay to analyze attacks.
    </li>
    <li>
     Use shells and scripting for programming and remote connection.
    </li>
    <li>
     Use Linux commands and utilities.
    </li>
    <li>
     Use a logging utility to manipulate and add information to log files.
    </li>
</ul>

The key terms for this section include:

<table class="terms">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Term
    </th>
    <th scope="col" class="fw-bold">
     Definition
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Packet capture
    </td>
    <td>
     Packet capture is the process of collecting Layer 3 (Network layer, such as IP address) information, over the wire.
    </td>
   </tr>
   <tr>
    <td>
     TCPDUMP
    </td>
    <td>
     TCPDUMP is a Linux tool that collects packet data. The data can be stored for later analysis.
    </td>
   </tr>
   <tr>
    <td>
     Wireshark
    </td>
    <td>
     Wireshark is a network protocol analyzer.
    </td>
   </tr>
   <tr>
    <td>
     TCPReplay
    </td>
    <td>
     TCPReplay is a tool you can use repeatedly simulate an attack.
    </td>
   </tr>
   <tr>
    <td>
     Secure Shell (SSH)
    </td>
    <td>
     SSH is a remote administration protocol that allows admins to securely connect to remote systems.
    </td>
   </tr>
   <tr>
    <td>
     PuTTY
    </td>
    <td>
     PuTTY is open-source software that supports several protocols, including SSH and Telnet.
    </td>
   </tr>
   <tr>
    <td>
     Secure Sockets Layer (SSL)
    </td>
    <td>
     SSL is a security encryption protocol that allows secure connections to remote systems.
    </td>
   </tr>
   <tr>
    <td>
     Public Key Infrastructure (PKI)
    </td>
    <td>
     PKI provides a system for the secure transmission of data. One component of PKI is the use of a key
        pair, one public and one private, that can be used to encrypt data. It also uses certificates to verify identity.
    </td>
   </tr>
   <tr>
    <td>
     Python
    </td>
    <td>
     Python is an object-oriented programming language often used for scripting
    </td>
   </tr>
</tbody></table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Exam
    </th>
    <th scope="col" class="fw-bold">
     Objective
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     CompTIA Security+ SY0-601
    </td>
    <td>
     1.4 Given a scenario, analyze potential indicators 
		associated with network attacks.
     <ul>
      <li>
       Layer 2 attacks
      </li>
     </ul>
     <p>
      1.7 Summarize the techniques used in security assessments.
     </p>
     <ul>
      <li>
       Syslog/Security information and event management (SIEM)
       <ul>
        <li>
         Review reports
        </li>
       </ul>
      </li>
     </ul>
     <p>
      4.1 Given a scenario, use the appropriate tool to assess organizational security.
     </p>
     <ul>
      <li>
       File manipulation
       <ul>
        <li>
         head
        </li>
        <li>
         tail
        </li>
        <li>
         cat
        </li>
        <li>
         grep
        </li>
        <li>
         chmod
        </li>
        <li>
         logger
        </li>
       </ul>
      </li>
      <li>
       Shell and script environments
       <ul>
        <li>
         SSH
        </li>
        <li>
         PowerShell
        </li>
        <li>
         Python
        </li>
        <li>
         OpenSSL
        </li>
       </ul>
      </li>
      <li>
       Packet capture and replay
       <ul>
        <li>
         Tcpreplay
        </li>
        <li>
         Tcpdump
        </li>
        <li>
         Wireshark
        </li>
       </ul>
      </li>
     </ul>
     <p>
      4.3 Given an incident, utilize appropriate data sources to support an investigation.
     </p>
     <ul>
      <li>
       Log files
       <ul>
        <li>
         System
        </li>
       </ul>
      </li>
     </ul>
    </td>
   </tr>
</tbody></table>

## 12.6.1 Manipulating Files

### Manipulate Files 00:00-00:32

In this lesson, we'll go over how to utilize and manipulate files. This includes viewing files, changing their permissions, searching, and logging. These skills are an important component of the overall skills you should have to succeed as a security professional. While not completely necessary, understanding the Linux operating system helps substantially since most hacking tools are made to run inside Linux. Let's look at six Linux commands and how they work.

### Linux Commands 00:32-01:35

First, a few words about Linux and Linux commands. A significant difference with Linux is that it's a case-sensitive operating system, so using lowercase or uppercase makes a difference. This means that FILE.TXT and file.txt are two different files. This holds true for parameters and modifiers as well. Linux also has built-in help, so you can use these commands to find information about the commands themselves, or you can use the internet to look up the information.

Use the ‘man' command to get metainformation about a command's purpose and parameters. The ‘info' command is much more verbose and explains the command in more detail. Finally, the ‘--help' command line parameter shows you parameter options, but it doesn't give explanations for their usage. Another option is to use the internet. You could search for Linux command examples to find links with the same information.

### Cat Utility 01:35-03:17

The first thing we'll review is the cat utility. Cat is used to display file contents onto the output device to see what's actually in a file. We often see it used in conjunction with other programs that manipulate output, but cat has several output manipulation options on its own that we'll look at. Again, Linux is case-sensitive and this applies to parameters.

`-n` places a sequential number at the beginning of each line. This helps identify output lines using numbers.

`-s` reduces the output if there are sequential empty lines. Cat displays only one empty line rather than many.

`-E` makes it easier to find line ends. This option places a dollar sign at the end of each line.

`-T` helps display certain characters. Tabs and other control characters are generally non-printing. In other words, they can't be displayed correctly on screen. Here, a ^I is displayed in the tab's place.

Let's take a look at some real-world examples. This screen shows the output using ‘cat' to display the sample.txt file.

Using the ‘–n' modifier, this screen shows output in which all lines are numbered.

It's possible to combine multiple parameters as well. Here, we have an example showing a combination that suppresses extra blank lines, adds line numbering, replaces the tab character with a ^I, and puts a dollar sign at the end of each output line.

### Head and Tail 03:17-04:38

Head and tail are great utilities for when you want to examine a file's beginning or end. By default, ‘head' displays a file's first ten lines and ‘tail' displays the last ten. Of course, you can configure these to display a different number of lines if you want. For example, ‘-n' is used to display a number of lines other than ten, and ‘-q' is used to omit printing description information.

Here, the output's first part shows a file's complete listing with the cat utility. Then, the ‘head' command was used to display only the file's first ten lines.

This example shows the ‘cat' command displaying the entire file. The second command shows the ‘tail' command with the ‘–n' parameter limiting the output to five lines.

The tail command also has a couple of additional parameters that are useful when viewing real-time changes. The ‘–f' or ‘–F' parameters display output in conjunction with file growth, similar to a log file. This is extremely useful for troubleshooting and monitoring system operations. The ‘–s' parameter can be added to reduce system stress by sleeping for a determined number of seconds between updates.

### Grep 04:38-06:13

Grep is very useful for filtering output data and is one of Linux's most used and customizable tools. There are so many dozens of settings available that it would be impossible to describe all of them here. The man page alone is over 600 lines long. But for our discussion, let's go over a couple of fairly universal grep uses you should know.

One of the most common grep uses is to find specific text in a file. This is done by using the pipe symbol and the ‘cat' command. As you recall, ‘cat' displays a file on the screen. The pipe, or vertical bar, takes the output from the command to the pipe's left and uses it as input for the command on the right. Here, the ‘cat' command produces output, which is the contents of the file we specified. The ‘grep' command uses that information as input, looks for the pattern, and outputs lines that contain the pattern we specified. All other lines are ignored. Another useful parameter is ‘–i', which ignores the pattern's case.

The ‘mount' command is another Linux command that shows us all mounted physical and virtual drive mounts on our system. This command shown here filters the output to display only drives that have the text sda on the line. You can see there are two drive mounts that are using the disk sda. The mount that's using sda1 is mounted as /boot and the disk sda6 is mounted on /var.

### Chmod 06:13-09:13

Use ‘chmod' to change file or directory permissions. In Linux, there are three sets of three permissions each. The three permissions are: r for read, w for write, and x for execute. The three sets of permissions are: user—the file or directory's owner, group—the group owner, and other—everyone else. In addition, the ‘–R' parameter provides for setting permissions recursively for all of the directory's contents.

Permissions can be assigned by values or mnemonics. Permission values are: r=4, w=2, and x=1. The mnemonic values are: u for user, g for group, and o for other. With numeric values, a combination of values needs to be used to provide permissions separately for a user or group. This can be any value between 0 and 7, where 0 provides no permissions and 7 provides all permissions. When we look at the

Linux file system, the permission set is listed in order. So user, group, and then other. If the first character is a dash, that means it's a file. If the first character is a d, it's a directory.

On the chart at the top of the page, we have a few examples of how to set file and directory permissions. A chmod value of 755 removes the write permission from the group and other, so rwxr-xr-x. 644 removes the execute permission from all instances, so rw-r—r--. The last example provides full permissions to the file owner but nothing to all other users, so rwx------.

Using mnemonics provides more granularity to assigning permissions. Not only can you define and set permissions, you can also add and subtract them from an existing set. The format is chmod followed by the user type u, g, or o. Also, type a is available for all types. You follow this with an equal sign to set permissions, a plus sign to add permissions, or a minus sign to remove them. This is followed by the r, w, or x permission. As an example, we have u=rwx,g=rx,o=rx. This is equivalent to the first numeric setting. Chmod a+x adds the execute permission to all user types. Another useful example is removing the write permission from the group and other user types with chmod g-w,o-w.

### Logger 09:13-10:29

Cybersecurity analysts examine a system's log files for activity traces while they try to figure out what was done to a system. Most Linux systems are configured to log almost everything—whether a process ran correctly, which processes were attempted, and who logged in or out. Some companies consolidate their logs to a system logging server, or syslog. This program allows you to add log messages and perform other functions. Be cautious, though, because hackers can utilize this function to throw off administrators by adding bogus information to the system log.

Like the other commands, a Linux logger has many command line parameters to customize system operations. A few of these parameters are listed here:

‘-n' defines the remote syslog server. First, UDP is attempted as the preferred transport protocol. If that fails, TCP is attempted.

‘-P' defines the TCP/IP port number used for the syslog server.

‘-t' defines a tag added to the system log. The default is the effective user ID.

### Summary 10:29-11:25

That's it for this lesson. Many systems used by hackers and defenders alike utilize Linux, so knowing how to use even a few commands is a great benefit. In this lesson, we learned about three utilities that display information: cat, head, and tail. Tail has the ability to allow real-time viewing while data is being added to a file. Grep is a widely used and powerful utility that filters output and makes it more readable. Chmod is the utility you use to change file and directory permissions, and you can choose to use numerics or mnemonics to do so. You can also recursively set permissions to all directory files with chmod. Lastly, we looked at logger. This logging utility allows you to manipulate log files and add information to them.

## 12.6.2 Manipulating Files Facts

This lesson covers the following topics:

<ul>
   <li>
    File viewing commands
   </li>
   <li>
    File management commands
   </li>
</ul>

### File Viewing Commands

The following commands can be used to control how Linux files are viewed:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">Command</th>
        <th scope="col" class="fw-bold">Function</th>
        <th scope="col" class="fw-bold">Examples</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>cat</td>
        <td>
        Displays the contents of a file in the shell. This command can
        display multiple files at once.
        </td>
        <td>
        <ul>
            <li>
            <b class="fw-bold"> cat myfile </b>
            - Displays the contents of myfile.
            </li>
            <li>
            <b class="fw-bold"> cat myfile yourfile </b>
            - Displays the contents of myfile and yourfile together.
            <br />
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>head</td>
        <td>
        Lists the first 10 lines (the default) of a specified file. Use the
        <b class="fw-bold"> -n </b>
        option to specify the number of lines to display.
        </td>
        <td>
        <ul>
            <li>
            <b class="fw-bold"> head /home/user/myfile </b>
            - Lists the first 10 lines of myfile.
            </li>
            <li>
            <b class="fw-bold"> head -n 20 /home/user/myfile </b>
            - Lists the first 20 lines of myfile.
            </li>
            <li>
            <b class="fw-bold"> head -n -35 /home/user/myfile </b>
            - Displays all lines in myfile, omitting the last 35 lines.
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>tail</td>
        <td>
        Lists the last 10 lines (the default) of a specified file.
        <ul>
            <li>
            <b class="fw-bold"> -n </b>
            - Specifies a specific number of lines.
            </li>
            <li>
            <b class="fw-bold"> -f </b>
            - Monitors the file.
            </li>
        </ul>
        </td>
        <td>
        <ul>
            <li>
            <b class="fw-bold"> tail /home/user/myfile </b>
            - Lists the last 10 lines of myfile.
            </li>
            <li>
            <b class="fw-bold"> tail -n 20 /home/user/myfile </b>
            - Lists the last 20 lines of myfile.
            </li>
            <li>
            <b class="fw-bold"> tail -n -15 /home/user/myfile </b>
            - Displays all lines in myfile, omitting the first 15 lines.
            </li>
            <li>
            <b class="fw-bold"> tail -f /var/firewalld </b>
            - Displays the last 10 lines of /var/firewalld and then
            dynamically displays new lines in the file as they are added.
            </li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

### File Management Commands

Linux files can also be managed using the following commands:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">Command</th>
        <th scope="col" class="fw-bold">Description</th>
        <th scope="col" class="fw-bold">Examples</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>
        <b class="fw-bold"> chmod </b>
        </td>
        <td>
        Assigns a special permission. Be aware of the following syntax
        options:
        <ul>
            <li>
            <b class="fw-bold">
                <i class="fs-italicize"> [decimal_value] </i>
            </b>
            - Sets the permissions for the file according to the numbers
            represented for each mode category.
            <ul>
                <li>
                The special permission precedes the standard octal
                representation of a set of permissions.
                </li>
                <li>
                Only the first number changes to identify the special
                permission group settings.
                </li>
            </ul>
            </li>
            <li>
            <b class="fw-bold">
                <i class="fs-italicize"> [category] </i>
            </b>
            +
            <b class="fw-bold">
                <i class="fs-italicize"> [permission] </i>
            </b>
            - Adds a special permission for a user, group, or other
            (category) to a file.
            </li>
            <li>
            <b class="fw-bold">
                <i class="fs-italicize"> [category] </i>
            </b>
            -
            <b class="fw-bold">
                <i class="fs-italicize"> [permission] </i>
            </b>
            - Removes a special permission for a user, group, or other from
            a file.
            </li>
        </ul>
        </td>
        <td>
        <ul>
            <li>
            <b class="fw-bold">
                chmod 4
                <i class="fs-italicize"> xxx </i>
            </b>
            - Sets the set owner userid (SUID).
            </li>
            <li>
            <b class="fw-bold"> chmod u+s </b>
            - Sets the SUID.
            </li>
            <li>
            <b class="fw-bold"> chmod u-s </b>
            - Removes the SUID.
            </li>
            <li>
            <b class="fw-bold">
                chmod 2
                <i class="fs-italicize"> xxx </i>
            </b>
            - Sets the set group ID (SGID).
            </li>
            <li>
            <b class="fw-bold"> chmod g+s </b>
            - Sets the SGID.
            </li>
            <li>
            <b class="fw-bold">
                chmod 1
                <i class="fs-italicize"> xxx </i>
            </b>
            - Sets the sticky bit.
            </li>
            <li>
            <b class="fw-bold"> chmod u+t </b>
            - Sets the sticky bit.
            </li>
            <li>
            <b class="fw-bold"> chmod u-t </b>
            - Removes the sticky bit.
            </li>
            <li>
            <b class="fw-bold">
                chmod 6
                <i class="fs-italicize"> xxx </i>
            </b>
            - Sets both the SUID and SGID.
            </li>
            <li>
            <b class="fw-bold">
                chmod 7
                <i class="fs-italicize"> xxx </i>
            </b>
            - Sets the SUID, GUID, and sticky bit.
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>
        <b class="fw-bold"> grep </b>
        </td>
        <td>
        Searches through files for a specified character string. By default,
        <b class="fw-bold"> grep </b>
        is context sensitive and displays the string in the context of the
        line containing the string.
        <ul>
            <li>
            <b class="fw-bold">
                -A
                <i class="fs-italicize"> [number] </i>
            </b>
            - Prints a specified number of lines following the matching
            lines.
            </li>
            <li>
            <b class="fw-bold"> -a </b>
            - Searches binary (executable) files as though they were text
            files.
            </li>
            <li>
            <b class="fw-bold">
                -B
                <i class="fs-italicize"> [number] </i>
            </b>
            - Prints a specified number of lines before the matching lines.
            </li>
            <li>
            <b class="fw-bold">
                -C
                <i class="fs-italicize"> [number] </i>
            </b>
            - Prints a specified number of lines of context around the
            matching lines.
            </li>
            <li>
            <b class="fw-bold"> -c </b>
            - Shows the number of matches of the string for the file.
            </li>
            <li>
            <b class="fw-bold"> -E </b>
            - Uses regular expressions for the text pattern.
            </li>
            <li>
            <b class="fw-bold">
                -e
                <i class="fs-italicize"> [pattern] </i>
            </b>
            - Specifies a literal pattern.
            </li>
            <li>
            <b class="fw-bold"> -f </b>
            - Searches for multiple strings using a file that lists the
            string patterns.
            </li>
            <li>
            <b class="fw-bold"> -l </b>
            - Lists the names of the files with a match. This is used to
            search multiple files.
            </li>
            <li>
            <b class="fw-bold">
                -m
                <i class="fs-italicize"> [number] </i>
            </b>
            - Shows the specified number of matches for a file.
            </li>
            <li>
            <b class="fw-bold"> -n </b>
            - Displays the line number of the lines containing the term.
            </li>
            <li>
            <b class="fw-bold"> -r </b>
            - Searches the directory and all subdirectories for files
            containing the term.
            </li>
            <li>
            <b class="fw-bold"> -v </b>
            - Displays non-matching lines.
            </li>
            <li>
            <b class="fw-bold">
                --include=
                <i class="fs-italicize"> [file_name] </i>
            </b>
            - Searches in files with names that match a specified string.
            </li>
            <li>
            <b class="fw-bold">
                --exclude=
                <i class="fs-italicize"> [file_name] </i>
            </b>
            - Searches in files with names that do not match a specified
            string.
            </li>
            <li>
            <b class="fw-bold"> -w </b>
            - Searches for whole words only.
            </li>
        </ul>
        </td>
        <td>
        <ul>
            <li>
            <b class="fw-bold"> grep -A 3 Midway ~/docs/WWII-report </b>
            - Searches WWII-report for the pattern Midway and prints the
            line and the next three lines.
            </li>
            <li>
            <b class="fw-bold"> grep -a var11 /bin </b>
            - Searches all files, including binary files, in the /bin
            directory for the pattern var11.
            </li>
            <li>
            <b class="fw-bold"> grep -c Midway ~/docs/WWII-report </b>
            - Shows a number representing the number of times the pattern
            Midway was found in the WWII-report file.
            </li>
            <li>
            <b class="fw-bold"> grep -C -3 Midway ~/docs/WWII-report </b>
            - Shows the specified number of lines preceding and following
            the matching lines.
            </li>
            <li>
            <b class="fw-bold"> grep -e '--count' ~/docs/doc1 </b>
            - Looks for the pattern --count in the doc1 file rather than
            interpreting it as an option.
            </li>
            <li>
            <b class="fw-bold"> grep -l -r Midway ~/docs </b>
            - Shows the name of all files in the /home/user/docs directory
            that contain the term Midway.
            </li>
            <li>
            <b class="fw-bold"> grep -m 2 battle ~/docs/WWII-report </b>
            - Shows the first two times the term battle is found in the
            file.
            </li>
            <li>
            <b class="fw-bold">
                grep -n -i customVariable1 ~/java/program1.java
            </b>
            - Shows the line numbers of lines that have the term
            customVariable1 in the program1.java file. This ignores the
            case.
            </li>
            <li>
            <b class="fw-bold"> grep -r battle ~/docs/ </b>
            - Searches the directory and all subdirectories for the term
            battle.
            </li>
            <li>
            <b class="fw-bold"> grep -w tank ~/docs/WWII-report </b>
            - Searches for the whole word tank in the file.
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>
        <b class="fw-bold"> logger </b>
        </td>
        <td>
        Lets you add entries in the system log file. The syntax is
        <b class="fw-bold"> logger &lt;message&gt; </b>
        .
        <p>
            The message portion of the command can also be entered from the
            output of another command.
        </p>
        </td>
        <td>
        <ul>
            <li>
            <b class="fw-bold"> logger Here is my message </b>
            - Adds the line Here is my message to the log file.
            </li>
            <li>
            <b class="fw-bold"> logger 'who' </b>
            - Uses the output of the
            <b class="fw-bold"> who </b>
            command as the message to be added to the log file.
            </li>
            <li>
            <b class="fw-bold"> logger -f msg </b>
            - Adds the contents of the msg file to the log file.
            </li>
            <li>
            <b class="fw-bold"> logger --size 5 1234567890123467890 </b>
            - Limits the input to the first 5 Kib characters.
            </li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

## 12.6.3 Shells and Scripting

### Shells and Scripting 00:00-00:48

A Linux shell refers to the ability to open a terminal and interact with the operating system directly. You enter commands and the system responds. There's no graphical user interface to point and click with. This is the power of Linux.

Scripting allows you to create virtual programs that automate repetitive tasks. These programs contain statements, commands, and logic and are often used to start processes, perform backups, and complete system maintenance. Microsoft also developed a system to mimic the same functionality called PowerShell, and there's an option in Windows that substitutes PowerShell for Command Prompt. In this lesson, I'll discuss shells and the Python programming language as well as how to use OpenSSL with SSH to secure and protect remote access.

### Remote Access 00:48-03:13

When you interact with a computer system, you generally sit at a desk and work on the computer nearest to you. The keyboard, mouse, and monitor are all physically connected to the system itself. Often, though, a system administrator has to work on systems that are in another room, a data center, or maybe even half-way across the world. Physically connecting to those systems is obviously impractical. Instead, admins connect to these systems remotely.

With Linux, admins use SSH, or Secure Shell. If you need to use a Windows machine to remotely connect to a Linux system, you'll probably have to use a program called PuTTY to make the SSH connection. PuTTY is open-source software that supports several protocols, including SSH, Telnet, and serial connections.

PuTTY, as shown here on Windows, allows the user to input an IP address or DNS name for their connection. The user chooses the connection type, which in this case is SSH. If successful, a window opens with a connection to the remote system, and the user is prompted to enter their credentials. If it all checks out, the user now has remote-system terminal access. It's important to understand how credentials can be stolen and misused over various remote connections. To help protect yourself against potential attacks when you do connect to remote systems, consider adding SSL, or Secure Sockets Layer.

SSL is a method that provides an encryption standard that's widely used by internet websites. When you connect to a secure website, such as a financial institution or shopping site, that site is protected by SSL. Remote access, including PuTTY, can take advantage of the same encryption standard by utilize OpenSSL, which is an open-source implementation. OpenSSL creates a key pair using encryption standards like DSA or RSA. The key pair is used by the public key infrastructure, or PKI. The PKI provides a pair of keys—one public and one private—that create an encrypted data stream when used together.

While a full lesson on PKI and SSL is outside the scope of this discussion, the idea is that when the client—the remote system, in other words—wants to send a message, he or she uses the public key provided by the host to encrypt the message. The host decrypts the message using the private key. When the host sends the client a message back, it's encrypted using the private key as well. And when the client receives that message, it's decrypted with his or her public key.

### Shells 03:13-04:12

Practically, all operating systems utilize a shell or text-based interface to provide operating system interaction. In Windows, we use Command Prompt. In Linux, we use the Terminal. Both systems also have methods for booting the system into the shell rather than into the graphical user interface. You can perform file maintenance, run programs, and do practically everything you could do graphically with the shell instead. Beyond that, you generally have greater control granularity since many graphical programs provide subsets of available program options.

In Windows, Command Prompt is the shell that provides an interactive platform to the operating system. You can copy, delete, rename files and directories, run programs, and create batch files.

Some reasons the shell is important is that it's the primary interface that interprets commands and runs scripts. Linux has more shell variety as there are several to choose from. We have Korn shell, TC shell, Bourne shell, and Bourne Again shell, which is the most commonly used. Each has their own unique characteristics, but they all provide the same basic functionality.

### Scripting 04:12-05:04

Scripting, or shell scripting, is most often used to automate tasks. A script's basic purpose is to execute a series of logical commands using control structures. Linux scripts use a programming language that's very similar to the C programming language. We use variables, control structures, looping, and file system controls.

When you write a script, the created file is an executable text file. The shell needs to know that it's executing a script, so every script must begin with the #!/bin/bash heading. After that, you add the commands. Here, we're simply displaying the text, "Hello World!" onto the screen. In this example, there's only one command to execute. In an actual script, there might be thousands of lines that test results, trap errors, and check for logic failures. When the script is finished, the exit command terminates the operation.

### PowerShell 05:04-06:30

Windows PowerShell was first introduced in November of 2006 with Windows XP Service Pack 2. It was developed to enhance the versatility of the command line interface and add management capabilities to Windows. It's modelled after the Linux shell and has an expanded command set not natively found in Windows. Today, with Windows configuration, we can use it as an alternative to the standard Command Prompt window.

While we can use PowerShell as Windows' primary command line interface, it has much greater power in its programming capabilities. Like the Linux shell, PowerShell has the ability to utilize commands, control structures, loops, and add-ons for greater control. One such add-on is VMware. VMware can integrate with PowerShell to enhance the available commands, allowing an administrator to use PowerShell to control certain aspects of VMware and virtual machines.

PowerShell is an all-around powerful tool for admins. You can use it to write scripts to automate tasks, just like in Linux. Also, it can be used to run system diagnostics and manage services by starting, stopping or restarting them. It controls printers and print queues and can read, write, and change the Windows Registry. For networks, you can use PowerShell within Active Directory to add or modify users, workstations, and containers. Best of all, it can be used to write reports by querying Active Directory in order to provide a report of active users, known workstations, and last logins.

### Python 06:30-08:26

Now, let's talk about Python. Python is an object-oriented programming language often used for scripting. It was first created in the late 1980s, but its adoption and widespread use didn't really begin until the 2000s. Interestingly, Python wasn't name for the species of snake like many believe. It was actually named for the popular comedy show Monty Python's Flying Circus. Python is currently in its third iteration and has become one of the most popular languages across all operating systems, including Windows, MacOS, and Linux.

Another important distinction to be aware of is that Python is a general-purpose language that can be used to write stand-alone programs, unlike PHP or JavaScript, which are meant solely for the internet and browsers. Pythons is considered a well-rounded language that's easy to pick up for beginners. People use it for web apps, scientific applications, data science, robotics, and machine learning, which is a superset of AI. Python gets its versatility from its extensive list of plug-in libraries, which expand the language far beyond what it can initially offer.

Here's a code segment used to check if the user's input year is a leap year. The code first defines the year as 2000 and then goes through a few checks to determine whether or not it's a leap year or not. If you're a programmer, much of this code probably looks familiar. If not, you might struggle through reading this. But don't worry, you should still be able to get a small idea of what's going on.

The program first checks to ensure that the year is divisible by 4. If not, the year is obviously not a leap year. If it is, it checks to see if the year is divisible by 100. If it's divisible by 100, it checks to see if the year is divisible by 400. If it is, the year is a leap year. The indenting is just something programmers use to make everything easier to read. Also, each line that begins with the pound sign is a human-readable comment not interpreted by Python. This is also just to make the code more readable.

### Summary 08:26-09:00

That's all for this lesson. In this lesson, we learned about shells and scripting. First, we learned about remote access to systems using SSH and OpenSSL for encryption. We learned that both Windows and Linux support shells and utilize a command line interface or a non-graphical interface for issuing commands and working with the operating system. Then we saw how PowerShell provides Windows with an expanded toolset for working within Active Directory. Last of all, we reviewed the Python programming language and its versatility and power.

## 12.6.4 Shells and Scripting Facts

A shell refers to the mechanism that allows you to interact with the operating system directly. You enter shell commands in a terminal window and the system responds. Scripting allows you to create virtual programs that automate repetitive tasks. These programs contain statements, commands, and logic. They are often used to start processes, perform backups, and complete system maintenance.

This lesson covers the following topics:

<ul>
   <li>
    SSH (Secure Shell)
   </li>
   <li>
    OpenSSL
   </li>
   <li>
    Scripting environments
   </li>
</ul>

### SSH (Secure Shell)

The SSH (Secure Shell) protocol is used to secure and encrypt the connection between a client and a server, or other remote device. All user authentication, commands, output, and file transfers are encrypted to protect against attacks in the network. To use SSH, you need an SSH terminal emulator such as PuTTY.

PuTTY is an SSH and Telnet client, developed originally for the Windows platform. PuTTY is open source software that is developed and supported by a group of volunteers. PuTTY is just one example of a terminal emulator.

SSH can be used for many applications across different platforms including Linux and Windows. SSH can be used for such things as:

<ul>
   <li>
    Logging in to a shell on a remote host, Linux, firewalls, and other network device.
   </li>
   <li>
    Executing commands on a remote host.
   </li>
   <li>
    Setting up automatic (passwordless) login to a remote server.
   </li>
   <li>
    Securing file transfer protocols.
   </li>
</ul>

### OpenSSL

SSL is a method that provides an encryption standard that’s widely used by internet websites. When you connect to a secure website, such as a financial institution or shopping site, that site is protected by SSL. Remote access, including PuTTY, can take advantage of the same encryption standard by using OpenSSL, which is an open-source implementation. OpenSSL creates a key pair using encryption standards such as DSA or RSA.

### Scripting Environments

A scripting or script language is a programming language for a special run-time environment that automates the execution of tasks. The term scripting language often refers to programs, such as Bash, PowerShell, and Python.

Scripting is often used in software applications, web pages within a web browser, the shells of operating systems (OS), embedded systems, network tasks, as well as numerous other applications. Scripts can be thought of as a small program up to a few thousand lines of code.

As a Security Analyst, you must be familiar with the different scripting languages and recognize the differences.

The table below identifies comparisons in Bash, Python, and PowerShell scripting languages.

<table width="430">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Comparison
    </th>
    <th scope="col" class="fw-bold">
     Bash
    </th>
    <th scope="col" class="fw-bold">
     Python
    </th>
    <th scope="col" class="fw-bold">
     PowerShell
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Equal
    </td>
    <td>
     -eq
    </td>
    <td>
     ==
    </td>
    <td>
     eq
    </td>
   </tr>
   <tr>
    <td>
     Not Equal
    </td>
    <td>
     -ne
    </td>
    <td>
     != or &lt;&gt;
    </td>
    <td>
     ne
    </td>
   </tr>
   <tr>
    <td>
     Greater Than
    </td>
    <td>
     -gt
    </td>
    <td>
     &gt;
    </td>
    <td>
     gt
    </td>
   </tr>
   <tr>
    <td>
     Greater or Equal
    </td>
    <td>
     -ge
    </td>
    <td>
     &gt;=
    </td>
    <td>
     ge
    </td>
   </tr>
   <tr>
    <td>
     Less Than
    </td>
    <td>
     -lt
    </td>
    <td>
     &lt;
    </td>
    <td>
     lt
    </td>
   </tr>
   <tr>
    <td>
     Less or Equal
    </td>
    <td>
     -le
    </td>
    <td>
     &lt;=
    </td>
    <td>
     le
    </td>
   </tr>
</tbody></table>

Like all programming languages, there are many common components of each, such as being able to create variables, constants, arrays, and input comments. The table below defines some common programming terms.

<table>
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Term
    </th>
    <th scope="col" class="fw-bold">
     Definition
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Comment
    </td>
    <td>
     A
     <i class="fs-italicize">
      comment
     </i>
     is text in a program's code, script, or another file that is not meant to be used by the program or seen by
      the user running the program. However, it is seen when viewing the source code.
    </td>
   </tr>
   <tr>
    <td>
     Variable
    </td>
    <td>
     A
     <i class="fs-italicize">
      variable
     </i>
     is a named unit of data that is assigned a value. If and when the value is modified,
      the name does not change.
    </td>
   </tr>
   <tr>
    <td>
     Constant
    </td>
    <td>
     A
     <i class="fs-italicize">
      constant
     </i>
     is data or a value that does not change, unlike a
      variable.
    </td>
   </tr>
   <tr>
    <td>
     Array
    </td>
    <td>
     An
     <i class="fs-italicize">
      array
     </i>
     is a group of related data values, or elements, that are grouped together. All the array
      elements must be the same data type.
    </td>
   </tr>
   <tr>
    <td>
     If statement
    </td>
    <td>
     An
     <i class="fs-italicize">
      if
     </i>
     statement is a conditional statement that, if proven true, performs a function or displays
      information.
    </td>
   </tr>
   <tr>
    <td>
     If else statement
    </td>
    <td>
     An
     <i class="fs-italicize">
      if else
     </i>
     statement is a conditional statement that selects the statements to run depending
      on whether an expression is true or false.
    </td>
   </tr>
   <tr>
    <td>
     Else
    </td>
    <td>
     <i class="fs-italicize">
      Else
     </i>
     is a conditional statement that if previous conditions are not true displays alternate
      information or performs alternate commands.
    </td>
   </tr>
   <tr>
    <td>
     Else if
    </td>
    <td>
     <i class="fs-italicize">
      Else if
     </i>
     , is a conditional statement performed after an if statement that, if true, performs a
      function.
    </td>
   </tr>
   <tr>
    <td>
     String
    </td>
    <td>
     A
     <i class="fs-italicize">
      string
     </i>
     is a sequence of characters, either as a literal constant or as some kind of
      variable.
    </td>
   </tr>
   <tr>
    <td>
     Substring
    </td>
    <td>
     A
     <i class="fs-italicize">
      substring
     </i>
     is a prefix or suffix of any string. For example, a substring of the word
      computer could be: puter or comp.
    </td>
   </tr>
</tbody></table>

The table below compares code samples of Bash, Python, and PowerShell.

<table width="1108">
   <thead>
    <tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Concept
    </th>
    <th scope="col" class="fw-bold">
     Bash
    </th>
    <th scope="col" class="fw-bold">
     Python
    </th>
    <th scope="col" class="fw-bold">
     PowerShell
    </th>
   </tr></thead>
   <tbody><tr>
    <td>
     Comment
    </td>
    <td>
     # This line is commented out
    </td>
    <td>
     # This line is commented out
    </td>
    <td>
     # This line is commented out
    </td>
   </tr>
   <tr>
    <td>
     Variables
    </td>
    <td>
     FirstName = Dana
    </td>
    <td>
     FirstName = Dana
    </td>
    <td>
     $FirstName = Dana
    </td>
   </tr>
   <tr>
    <td>
     Constants
    </td>
    <td>
     InterestRate = 3.5%
    </td>
    <td>
     InterestRate = 3.5%
    </td>
    <td>
     $InterestRate = 3.5%
    </td>
   </tr>
   <tr>
    <td>
     Basic Arrays
    </td>
    <td>
     <p>
      numArray = (num1, num2, num3)
     </p>
    </td>
    <td>
     numArray = (num1, num2, num3)
    </td>
    <td>
     $numArray = @(num1, num2, num3)
    </td>
   </tr>
   <tr>
    <td>
     Fetch data stored in Arrays
    </td>
    <td>
     numArray = (num1, num2, num3)
     <br>
     echo {$numArray[0]}
    </td>
    <td>
     numArray = (num1, num2, num3)
     <br>
     print {$numArray[0]}
    </td>
    <td>
     $numArray = @(num1, num2, num3)
     <br>
     echo $numArray[0]
    </td>
   </tr>
   <tr>
    <td>
     IF
    </td>
    <td>
     if [@Cost-t $Balance]
     <br>
     then
     <br>
     # call payment function fi
    </td>
    <td>
     if Cost&lt;Balance:
     <br>
     #call payment function
    </td>
    <td>
     If ($Cost-lt $Balance) { # call payment function }
    </td>
   </tr>
   <tr>
    <td>
     IF, ELSEIF, ELSE
    </td>
    <td>
     if [&lt;example&gt;] then
     <br>
     # result
     <br>
     elif[&lt;example&gt;] then
     <br>
     # result
     <br>
     else
     <br>
     # result
     <br>
     fi
    </td>
    <td>
     if &lt;example&gt;:
     <br>
     # result
     <br>
     elif&lt;example&gt;:
     <br>
     # result
     <br>
     else:
     <br>
     # result
    </td>
    <td>
     if (&lt;example&gt;){
     <br>
     # result
     <br>
     } elseif(&lt;example&gt;) {
     <br>
     # result
     <br>
     } else {
     <br>
     }
     <br>
    </td>
   </tr>
   <tr>
    <td>
     Loops
    </td>
    <td>
     while [$x -eq $dog]
     <br>
     do
     <br>
     # commands
     <br>
     done
    </td>
    <td>
     animals = ["fox", "wolf", "dog"]
     <br>
     for x in animals:
     <br>
     print(x)
     <br>
     if x == "dog";
     <br>
     break
    </td>
    <td>
     Do {
     <br>
     # commands
     <br>
     } While ($x-eq $dog)
    </td>
   </tr>
   <tr>
    <td>
     String Operations
    </td>
    <td>
     sampleString = "Sample String"
     <br>
     echo ${sampleString}
     <br>
     echo ${sampleString:0:4}
     <br>
     echo ${sampleString/Sample/Sampling}
    </td>
    <td>
     sampleString = "Sample String"
     <br>
     print sampleString.uppercase
     <br>
     print sampleString.replace)Sample", Sampling")
    </td>
    <td>
     $sampleString - "Sample String"
     <br>
     echo $sampleString+ "2"
     <br>
     $sampleString.Substring(0:4)
    </td>
   </tr>
</tbody></table>

## 12.6.5 Packet Capture Manipulation

### Packet Capture Manipulation 00:00-00:39

Any discussion about security would be incomplete without covering packet capture amd network analysis. Capturing and viewing packets has been a part of network diagnostics for several years. Very little can hide in packets since they contain all of the information about data communications between devices. The source IP address, source MAC address, and target IP and MAC addresses are all listed in the packet. There's no abstraction, but it does take some getting used to. Gaining proficiency in packet capture helps both attackers and defenders discovery what's going out over the wire.

### Understanding Packets 00:39-01:41

Packet capture is the process of collecting Layer 3 information over the wire. TCP/IP communicates using packets and includes information in addition to the data contained in the packet. Each packet contains a header, payload, and trailer. It contains source and destination IP addresses, protocol information, error correction, packet sequence numbers, and more. In standard Ethernet, a packet is usually 1,500 bytes, but it can vary depending on use. For example, the jumbo packets used by disk subsystems can be anywhere from 1,000 to 9,000 bytes long.

Here, we have all the parts that make up an IP packet. You can see all of this information using a network analyzer. You can capture packets and store them for later analysis and, potentially, use them to attack a system. As an example, an attacker can change the destination address to the IP address of their machine and conduct a replay attack.

### TCPDUMP 01:41-03:48

When normal troubleshooting fails, it may be necessary to examine the conversation. Performing a packet capture and analysis may be the only method available for discovering the underlying issue. Packet capture is the process of collecting Layer 3 or IP information over the wire. Linux has a tool called TCPDUMP. It was developed for Linux in 1988. It collects packet data, which can be stored for later analysis. A version of TCPDUMP was created for Windows by Microolap and performs most of the same functions as it does in Linux. TCPDUMP is a powerful tool used to capture and examine packets. It has several command line options that provide a more granular control of the scan.

Here's a few of the options. ‘-i interface' specifies the Ethernet interface TCPDUMP should use for the scan. This is especially important if you're using a multi-homed system with more than one network interface card. Adding ‘a –n' turns off DNS lookups. This is useful if you're using internal scans where there's no internal DNS. To get more information, you can add ‘a –v' or, for even more verbosity, you can add two or three more Vs. The ‘–w' option writes the raw packets to a file rather than printing them out. This output is buffered. If packets must be written to the file when they're received, then you can add the capital U option.

This is a very small sample of a dump. It shows the data stream while starting the Firefox web browser. Approximately 300 packets were capture in about two seconds while the application opened. This sample shows four packets. The last packet, number 4, shows that we're using protocol #17, or UDP. It's a DNS answer providing our machine with DNS or CNAME information as well as IPv6 information. All of this happened in microseconds. It can take several hundred packets to perform the most simple data transfer.

### Wireshark 03:48-05:33

On their website, Wireshark is known as the world's foremost network protocol analyzer. It's the de facto standard for packet capture and analysis. It's available on all major operating systems, including Windows, Mac, Linux, and several Unix versions. It works predominantly with a GUI, but there's also a text version called TShark. Wireshark can read and write many different file formats, including tcpdump, Cisco secure IDS iplog, and Microsoft Network Monitor. It can receive input from Ethernet, Bluetooth, USB, and other communication standards. There are powerful filters on the most specific component to identify information. Wireshark has decryption support for IPsec, Kerberos, WPA, and more. It also has the ability to export data to XML, CSV, or plain text.

Wireshark is free to download, and its website is full of tutorials, sample captures, and click-to-learn features. The GUI is very easy to read and straightforward to use. First, choose the interface or interfaces to use, then click Start. Wireshark will display a packet capture screen showing the live data transfer and packet capture. When you're finished, click on the red stop icon.

Once you have the data captures within Wireshark, they can be manipulated with filters to locate specific data, such as packets going to or from a specific interface, IP address, or destination, specific protocols, certain broadcast, and so on. Once you have what you're looking for, you can save the output in various formats for inclusion in reports or for further analysis.

### TCPReplay 05:33-09:10

One of the most critical aspects of a cybersecurity plan is testing. Organizations may employ white-hat hackers to attempt attacks and report their findings so network managers can reconfigure security devices, address vulnerabilities, and mitigate potential risk. One tool that can be used to simulate attacks is TCPReplay. Once a packet capture is performed by TCPDump or Wireshark, it can be sent out again and again to test devices such as firewalls, IDS/IPS, and NetFlow, as well as infrastructure equipment such as switches and routers.

Using TCPDump or Wireshark, a simulated attack can be executed to capture packets. After manipulating the packet capture as needed, you can test the defensive equipment replaying the attack with TCPReplay. After the test, you can analyze the results for alerts and detection or prevention. The test will identify remediation points and reconfiguration needs. After remediation, the test can be replayed again, and the results are reevaluated. This can happen multiple times until network management deems the vulnerability closed.

TCPReplay may not be installed in your Linux distribution. Further, standard repositories may not contain the TCPReplay packages. Check with your Linux distro to ensure you know how to obtain the packages it needs.

The first step is to make sure that you have all of the latest updates. Since many distros don't include TCPReplay in the base installation and it's not included in the base repositories on RedHat distros, you must install the EPEL repository, which stands for Extra Packages for Enterprise Linux repository. Then it's time to install TCPReplay. At this point, your Linux system is ready to conduct security testing.

As in TCPDump, there are many flags and filters available to configure TCPReplay and provide the most appropriate data for testing security and infrastructure equipment. The options can affect the performance and actions of TCPReply and may skew results. Be sure to fully understand the options used. Further, several options can't be used together. Review the documentation or Linux man page for additional specific information.

-K takes information from the packet capture file and preloads it into RAM for faster access. Use this only if your system contains enough RAM. -M replays packets at a given mbps (megabits per second). This parameter can be used to throttle output. -L limits the number of packets sent. It can be used for limited tests to ensure that the system is set up correctly and to perform a quick end-to-end test. The lowercase –d parameter enables the verbosity for debug output. Used along with the enable-debug flag, the number can be in the range of 0 through 5. Higher numbers increase verbosity.

These are just a sampling of the many available options. TCPReplay can be a helpful tool used to test the success or failure of security equipment and infrastructure. When used correctly, it provides network management with the information they need to keep their organization as safe as possible against attack. It provides them with vulnerability data that can be remediated and tested again until the risk is minimized.

### Summary 09:10-10:00

That's it for this lesson. In this lesson, we discussed TCPDump, which captures packet data as at traverses the network. It's included is most Linux distributions' base image. It's easy to use and highly customizable.

We looked at Wireshark for capturing network protocol information at the packet level, filtering the information in any way desired, and reporting data in several formats. It's the de facto standard.

And we finished by discussing TCPReplay, which can be downloaded using YUM and APT and provides a way to analyze an attack to provide network management key information and remediate potential vulnerabilities. Mastering these tools helps to keep a network safe and minimizes potential risk.

## 12.6.6 Use TcpReplay

### Use Tcpreplay 00:00-00:26

In this demonstration, we'll cover how to use the tool, Tcpreplay. It allows a packet capture file (PCAP) to be played back to the active network. This could be for a malicious purpose, such as an attacker using a previously captured login to gain access to a system. Or, it could be a security analyst testing security tools like Snort to make sure malicious traffic is properly identified.

### Load the PCAP File 00:26-01:18

Security Onion comes with multiple sample capture files. We are going to use one of those with Tcpreplay. First, go to Applications > Utilities > Terminal. Once the terminal is open, click File and then Open Terminal to open a second terminal. We'll use this to see if Snort detects the exploit traffic.

In that window, we'll tail the snort_agent-1.log where the Snort alerts are being written. We'll type —˜tail -f' followed by the path and filename. The tail command reads the file and outputs the last part of it, known as the tail.

The -f switch indicates for the system to continue displaying lines as they are added. This is commonly used to watch log files in real time. As new lines are written to the log, the console will update with new lines.

### Begin the Replay 01:18-01:50

In the first terminal window type —˜sudo tcpreplay' to begin the replay. Use the -I switch to identify the interface followed by the name of the interface. We follow that with the path of the PCAP file we want to replay.

This will play those packets onto the sniffer interface. As you can see, Snort is detecting malicious traffic created by the packets that we are replaying. Tcpreplay shows that we had 17 attempted packets and they were all successfully sent.

### Summary 01:50-02:02

That's it for this demo. In this demo, we showed how you can use Tcpreplay to play back PCAP files for further analysis.

## 12.6.7 Packet Capture Facts

This lesson covers the following topics:

<ul>
   <li>
    Packet capturing
   </li>
   <li>
    Switched network sniffing
   </li>
   <li>
    Wireshark
   </li>
   <li>
    TCPDump
   </li>
   <li>
    TCPReplay
   </li>
   <li>
    Additional sniffing tools
   </li>
</ul>

### Packet Capturing

Packet capturing, also referred to as sniffing, is the process of collecting information as it crosses the network. Sniffing is similar to eavesdropping or wiretapping. It can be active or passive. Monitoring traffic is passive sniffing. Altering traffic in any way is active sniffing.

For sniffing to be effective, the network interface must be in promiscuous mode. Normally, an interface is set to grab frames that are directed only to its own MAC address. Turning on promiscuous mode gives the interface permission to grab every frame that comes its way, even if the frame is addressed to someone else. A lot of information can be gathered during this process. Attackers examine each packet closely to see which ones are useful.

There are several tools an attacker can use to make this job much easier, But’s important to know what attackers focus on. One key area of focus is packets that are sent with less-secure protocols. Many protocols were designed with the concept that encryption happens at another layer. For example:

<ul>
    <li>
     SMTP was designed to deliver an email message without encrypting it.
    </li>
    <li>
     POP3 was designed to retrieve emails, therefore passwords and usernames are easy to intercept from it.
    </li>
    <li>
     FTP was designed to transmit files; all FTP traffic is sent in clear text.
    </li>
    <li>
     IMAP, HTTP, and Telnet send passwords and data using clear text.
    </li>
</ul>

### Switched Network Sniffing

Networks that include switches can provide an initial challenge to an attacker because switches prevent sniffing an entire network. The following table lists methods an attacker can use to sniff out portions of a network.

<table>
    <thead>
     <tr><th scope="col" class="fw-bold">
      Method
     </th>
     <th scope="col" class="fw-bold">
      Description
     </th>
    </tr></thead>
    <tbody><tr>
     <td>
      MAC spoofing
     </td>
     <td>
      A common low-level security measure is port security. Port security allows only specific MAC addresses
        to access a switch. The goal is to ensure that only authorized devices have access to the network. A MAC address for a
        network interface card (NIC) is assigned by the manufacturer. This address is hard-coded directly into the NIC and can’t
        be changed.
      <p>
       However, on some interfaces it is possible to change the MAC address of the interface driver. This allows an attacker's computer
        to connect to a switch using an authorized MAC address. This allows the attacker to capture packets from that network.
      </p>
     </td>
    </tr>
    <tr>
     <td>
      MAC flooding
     </td>
     <td>
      When a switch is initially turned on, it doesn’t know which devices it will support. A
        switch uses a content addressable memory (CAM) table to track MAC addresses. As it receives packets from various MAC addresses,
        it adds the addresses to its CAM table and associates each one with a physical port on the switch. This process allows data
        to be sent directly to the port where the intended recipient is located instead of sending all data across the entire
        network like a hub.
      <p>
       Although one port can have multiple MAC addresses associated with it, the CAM table has a size limit. MAC flooding is the
        process of intentionally flooding the CAM table with Ethernet frames, each originating from a different MAC address.
      </p>
      <p>
       Once the table starts to overflow, the switch responds by broadcasting all incoming data to all ports, basically turning
        itself into a hub instead of a switch. When an attacker's MAC address is connected to one of the ports, the attacker can capture all traffic as it is broadcast across the network.
      </p>
     </td>
    </tr>
    <tr>
     <td>
      ARP poisoning
     </td>
     <td>
      The Address Resolution Protocol (ARP) maps IP addresses to MAC addresses and provides the most
        efficient path for data transmission. ARP broadcasts are permitted to freely roam the network. An attacker can use the free
        flow of traffic for an advantage.
      <p>
       By sending spoofed messages onto a network, the MAC address of the attacker can be associated with the IP address of another host, preferably the default gateway. As a result, the target machine will send frames to the attacker's 
        system, thinking that it is the gateway. The attacker will then typically forward the frame to the original destination.
      </p>
     </td>
    </tr>
    <tr>
     <td>
      Port mirroring
     </td>
     <td>
      Port mirroring can be challenging to set up, but is possible depending on the level of access an attacker has
        on a network. The concept behind port mirroring, also known as SPAN port, is simple. Port mirroring creates
        a duplicate of all network traffic on a port and sends it to another device. If all traffic from a target machine is
        directed through the switch to the server, an attacker can implement port mirroring.
      <p>
       Port mirroring ensures that all traffic is sent to the attacker’s machine as well as the target machine.
      </p>
     </td>
    </tr>
</tbody></table>

### Wireshark

Wireshark is one of the most well-known packet analyzers. It is available for Windows, Mac, and Linux operating systems. Wireshark has numerous tools that can be used to capture and analyze traffic. It includes search and filtering capabilities that make it a very powerful resource. These filtering commands can be typed into the filter window. The screen will display only the filtered data.

The following table lists commonly used filters:

<table>
    <thead>
     <tr><th scope="col" class="fw-bold">
      Operator
     </th>
     <th scope="col" class="fw-bold">
      Description
     </th>
    </tr></thead>
    <tbody><tr>
     <td>
      ==
     </td>
     <td>
      Equal (example: ip.addr == 192.168.1.3)
     </td>
    </tr>
    <tr>
     <td>
      eq
     </td>
     <td>
      Equal (example: tcp.port eq 161)
     </td>
    </tr>
    <tr>
     <td>
      contains
     </td>
     <td>
      Contains a specific value (example: http contains “http://www.stuff.com”
     </td>
    </tr>
    <tr>
     <td>
      ne
     </td>
     <td>
      Not equal (example: ip.src ne 192.168.1.3)
     </td>
    </tr>
    <tr>
     <td>
      !=
     </td>
     <td>
      Not equal (example: ip.addr != 192.168.1.3
     </td>
    </tr>
    <tr>
     <td>
      &amp;&amp;
     </td>
     <td>
      And (example ip.addr==192.168.1.3&amp;&amp;tcp.port=23)
     </td>
    </tr>
    <tr>
     <td>
      or
     </td>
     <td>
      Or (example ip.addr==192.168.1.3 or ip.addr ==192.168.1.4)
     </td>
    </tr>
</tbody></table>

### TCPDump

TCPDump is a command line sniffer designed for the Linux environment. This tool filters the contents of packets going through a network interface. TCPDump has several switches and options, a few of which you’ll find in the following table.

<table>
    <thead>
     <tr><th scope="col" class="fw-bold">
      Operator
     </th>
     <th scope="col" class="fw-bold">
      Description
     </th>
    </tr></thead>
    <tbody><tr>
     <td>
      -i
     </td>
     <td>
      Puts an interface into listening mode.
     </td>
    </tr>
    <tr>
     <td>
      -w
     </td>
     <td>
      Specifies the file the data should be saved in.
     </td>
    </tr>
    <tr>
     <td>
      -a
     </td>
     <td>
      Requests that ASCII strings are included in the output.
     </td>
    </tr>
    <tr>
     <td>
      -x
     </td>
     <td>
      Requests that ASCII and hexadecimal strings are included in the output.
     </td>
    </tr>
    <tr>
     <td>
      -v
     </td>
     <td>
      Turns on verbosity.
     </td>
    </tr>
    <tr>
     <td>
      -n
     </td>
     <td>
      Turns off DNS lookups.
     </td>
    </tr>
    <tr>
     <td>
      dst
     </td>
     <td>
      Requests that all traffic going to a specified destination is captured.
     </td>
    </tr>
    <tr>
     <td>
      src
     </td>
     <td>
      Requests that all information coming from a specified source is captured.
     </td>
    </tr>
    <tr>
     <td>
      host
     </td>
     <td>
      Requests that all traffic going to a specified destination and from a specified source is
        captured.
     </td>
    </tr>
    <tr>
     <td>
      pcap
     </td>
     <td>
      Requests that captured content be saved to a specified file.
     </td>
    </tr>
</tbody></table>

### TCPReplay

One of the most critical aspects of a cybersecurity plan is testing. Organizations may employ white-hat hackers to attempt attacks and report their findings so network managers can reconfigure security devices, address vulnerabilities, and mitigate potential risk. One tool that can be used to simulate attacks is TCPReplay. Once a packet capture is performed by TCPDump or Wireshark, it can be sent out again and again to test devices such as firewalls, IDS/IPS, and NetFlow, as well as infrastructure equipment such as switches and routers.

Using TCPDump or Wireshark, a simulated attack can be executed to capture packets. After manipulating the packet capture as needed, you can test defensive equipment replaying the attack with TCPReplay. After the test, you can analyze the results for alerts, detection, or prevention. The test will identify remediation points and areas that need reconfiguration. After remediation, the test can be replayed again, and the results are reevaluated. This can happen multiple times until network management deems the vulnerability closed.

TCPReplay has several switches and options, a few of which you’ll find in the following table.

<table>
    <thead>
     <tr><th scope="col" class="fw-bold">
      Operator
     </th>
     <th scope="col" class="fw-bold">
      Description
     </th>
    </tr></thead>
    <tbody><tr>
     <td>
      -K
     </td>
     <td>
      Takes information from the packet capture file and preloads it into RAM for faster access. Use this
        only if your system contains enough RAM.
     </td>
    </tr>
    <tr>
     <td>
      -M
     </td>
     <td>
      Replays packets at a given Mbps (megabits per second) rate. This parameter can be used to throttle the
        output.
     </td>
    </tr>
    <tr>
     <td>
      -L
      <i class="fs-italicize">
       number
      </i>
     </td>
     <td>
      Limits the number of packets sent. This can be used for limited tests to ensure that the system is set
        up correctly and to perform a quick end-to-end test.
     </td>
    </tr>
    <tr>
     <td>
      -d
      <i class="fs-italicize">
       number
      </i>
     </td>
     <td>
      Enables the verbosity for debug output. Used along with the enable-debug flag, the number can be in the
        range of 0 through 5. Higher numbers increase verbosity.
     </td>
    </tr>
</tbody></table>

TCPReplay can be a helpful tool used to test the success or failure of security equipment and infrastructure. When used correctly, it provides network management with the information needed to keep an organization as safe as possible against attack. It provides vulnerability data that can be remediated and tested again until the risk is minimized.

### Additional Sniffing Tools

The following table describes additional tools.

<table>
    <thead>
     <tr><th scope="col" class="fw-bold">
      Tool
     </th>
     <th scope="col" class="fw-bold">
      Description
     </th>
    </tr></thead>
    <tbody><tr>
     <td>
      Cain and Abel
     </td>
     <td>
      <i class="fs-italicize">
       Cain and Abel
      </i>
      is a collection of tools including ARP poisoning. Cain and Abel redirects packets from a target by
        forging ARP replies.
     </td>
    </tr>
    <tr>
     <td>
      Ufasoft Snif
     </td>
     <td>
      <i class="fs-italicize">
       Ufasoft Snif
      </i>
      is a network sniffer used to capture, decrypt, and analyze packets as they travel across the
        network.
     </td>
    </tr>
    <tr>
     <td>
      WinARPAttacker
     </td>
     <td>
      <i class="fs-italicize">
       WinARPAttacker
      </i>
      can scan, detect, and even attack computers on a LAN.
     </td>
    </tr>
    <tr>
     <td>
      Ettercap
     </td>
     <td>
      <i class="fs-italicize">
       Ettercap
      </i>
      has multiple sniffing functions and can be used for ARP poisoning, passive sniffing, packet grabbing, and
        protocol decoding.
     </td>
    </tr>
    <tr>
     <td>
      Etherflood
     </td>
     <td>
      <i class="fs-italicize">
       Etherflood
      </i>
      is a tool that can flood a switched network with random MAC addresses.
     </td>
    </tr>
    <tr>
     <td>
      SMAC
     </td>
     <td>
      <i class="fs-italicize">
       SMAC
      </i>
      is a spoofing tool that allows an attacker to spoof a MAC address to any value.
     </td>
    </tr>
    <tr>
     <td>
      WinDump
     </td>
     <td>
      <i class="fs-italicize">
       WinDump
      </i>
      is the Windows version of TCPDump.
     </td>
    </tr>
</tbody></table>
