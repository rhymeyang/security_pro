---
lang: zh-CN
title: Section 10.4 Application Development and Security
description: some description
---

As you study this section, answer the following questions:

<ul>
    <li>
     What are two common standardized software development models?
    </li>
    <li>
     How should security be implemented in the different stages of development?
    </li>
    <li>
     What are the responsibilities of developers after a product is released?
    </li>
    <li>
     What are some important application hardening techniques?
    </li>
</ul>

In this section, you will learn to:

<ul>
    <li>
     Harden applications on Linux.
    </li>
    <li>
     Implement Data Execution Preventions (DEP).
    </li>
    <li>
     Implement application whitelisting with AppLocker.
    </li>
</ul>

The key terms for this section include:

<table class="terms">
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">Term</th>
        <th scope="col" class="fw-bold">Definition</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Normalization</td>
        <td>
        Data reorganized in a relational database to eliminate redundancy by
        having all data stored in one place and storing all related items
        together.
        </td>
    </tr>
    <tr>
        <td>Stored procedures</td>
        <td>
        One or more database statements stored as a group in a database’s
        data dictionary, which when called, executes all the statements in
        the collection.
        </td>
    </tr>
    <tr>
        <td>Code obfuscation</td>
        <td>
        The deliberate act of creating source or machine code that is
        difficult for humans to understand. In other words, the code is
        camouflaged.
        </td>
    </tr>
    <tr>
        <td>Code reuse</td>
        <td>Using the same code multiple times.</td>
    </tr>
    <tr>
        <td>Dead code</td>
        <td>
        Code that is non-executable at run-time, or source code in a program
        that is executed but is not used in any other computation.
        </td>
    </tr>
    <tr>
        <td>Memory management</td>
        <td>
        A resource management process applied to computer memory. It allows
        your computer system to assign portions of memory, called blocks, to
        various running programs to optimize overall system performance.
        </td>
    </tr>
    <tr>
        <td>Third-party libraries</td>
        <td>A library where the code is not maintained in-house.</td>
    </tr>
    <tr>
        <td>Software Development Kits (SDKs)</td>
        <td>
        A set of software development tools that can be installed as one
        unit.
        </td>
    </tr>
    <tr>
        <td>Data exposure</td>
        <td>Unintended exposure of personal and confidential data.</td>
    </tr>
    <tr>
        <td>Fuzz testing</td>
        <td>
        A software testing technique that exposes security problems by
        providing invalid, unexpected, or random data to the inputs of an
        application.
        </td>
    </tr>
    <tr>
        <td>Code signing</td>
        <td>
        The process of digitally signing (encrypting) executables and
        scripts to confirm the software author and guarantee that the code
        has not been altered or corrupted since it was signed.
        </td>
    </tr>
    </tbody>
</table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">Exam</th>
        <th scope="col" class="fw-bold">Objective</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>TestOut Security Pro</td>
        <td>
        3.0 Host and Application Defense
        <p>3.1 Harden Computer Systems</p>
        <p>3.2 Implement Application Defenses</p>
        </td>
    </tr>
    <tr>
        <td>CompTIA Security+ SY0-601</td>
        <td>
        2.3. Summarize secure application development, deployment, and
        automation concepts.
        <ul>
            <li>
            Environment
            <ul>
                <li>Development</li>
                <li>Test</li>
                <li>Staging</li>
                <li>Production</li>
                <li>Quality assurance (QA)</li>
            </ul>
            </li>
            <li>Provisioning and deprovisioning</li>
            <li>Integrity measurement</li>
            <li>
            Secure coding techniques
            <ul>
                <li>Normalization</li>
                <li>Stored procedures</li>
                <li>Obfuscation/camouflage</li>
                <li>Code reuse/dead code</li>
                <li>Server-side vs. client-side execution and validation</li>
                <li>Memory management</li>
                <li>
                Use of third-party libraries and software development kits
                (SDKs)
                </li>
                <li>Data exposure</li>
            </ul>
            </li>
            <li>Open Web Application Security Project (OWASP)</li>
            <li>
            Software diversity
            <ul>
                <li>Compiler</li>
                <li>Binary</li>
            </ul>
            </li>
            <li>
            Automation/scripting
            <ul>
                <li>Automated courses of action</li>
                <li>Continuous monitoring</li>
                <li>Continuous validation</li>
                <li>Continuous integration</li>
                <li>Continuous delivery</li>
                <li>Continuous deployment</li>
            </ul>
            </li>
            <li>Elasticity</li>
            <li>Scalability</li>
            <li>Version control</li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

## 10.4.1 Development Life Cycle

### Development Lifecycle 00:00-00:31

In this lesson, we'll look at how to apply security concepts to software development. Even though you may not be a software developer yourself, most security professionals work with software engineers in some capacity. Just like other company resources, the applications they develop need to be properly secured.

Today, we'll look at the two most common development lifecycles to understand how you can secure each step throughout the development process.

### Waterfall Software Development Cycle Model 00:31-02:14

The most widely used development model is the Waterfall model. It's called this because each step is completed before the next step is begun. Each step flows to the next like a waterfall.

The first step in a Waterfall model is Requirements. All requirements for the application need to be gathered from the client, user, or stakeholder. The next step is Design. This is when the software is documented, diagrammed, and designed. After that, we have Implementation. This is the actual coding and building of the application.

We then have the Testing phase. During this phase, a quality assurance team makes sure that the team met the requirements, that the code works properly across devices, and that security flaws and vulnerabilities were phased out. After Testing comes the Deployment. This is when the application is released to a client or to the public. The final step is Maintenance. The application is in use in this phase, but it's monitored for bugs or problems that are quickly patched. This is an ongoing stage that continues throughout the app's life.

Understand that the application will likely go through some of these steps multiple times before moving on. For example, the application might go through the Design step five times before it's ready to move on to the Implementation step. Then the application may move from the Implementation stage back to the Design stage if a new feature needs to be added. This entire development cycle is a slow process and may take months or years to complete. The Waterfall method lacks flexibility since the requirements determined in the beginning carry through to the end product.

### Agile Model 02:14-02:37

A more agile approach was introduced in 2001 which approaches software development as a continuous, changing process with never-ending versions, bug fixes, and enhancements. This approach is aptly named Agile. One reason the Agile methodology is pragmatic is because security vulnerabilities are constantly addressed with new updates and fixes.

### Agile Model 02:37-03:23

Unlike Waterfall, Agile doesn't work on the entire application at once. Instead, it breaks development into smaller time frames called Sprints. Each Sprint has a specific duration, usually two to three weeks. Within this time frame, developers work on a specific application feature.

These features typically go through the same stages that all applications go through, such as Requirements, Design, Development, Testing, and Deployment. At the end of the Sprint, the developers move on to the next feature.

With Agile, you perform testing throughout the development cycle to help catch security vulnerabilities early. Waterfall, on the other hand, leaves testing until the end of the cycle. This can cause testing time to be cut short to meet deadlines.

### Coding Errors 03:23-04:09

Coding errors and design flaws are the main causes of software vulnerabilities. We can categorize these errors into two types: compile errors and runtime errors.

A compile error refers to an error that occurs during the building or compilation stage. The error compromises the software implementation, which prevents it from running at all.

A runtime refers to an error that occurs while the software is running. The software begins execution, but it fails when it cannot resolve a problem it encounters.

During the coding and design phases, you can increase application security by integrating security testing into each step of the process. Let's look at three testing methods: static, dynamic, and interactive application security testing.

### Static Application Security Testing 04:09-04:49

Static application security testing, or SAST, is also known as white box testing. SAST focuses on analyzing source code, binaries, and byte code early in the development process. SAST tools are good at identifying things like SQL-injection vulnerabilities and buffer overflows. They can identify the exact cause of a coding problem, but only in code not yet deployed. They're language specific, but you can run them continually and apply them widely. Please note that they do have a high percent of false positives and are limited in the types of vulnerabilities they can detect.

### Dynamic Application Security Testing 04:49-05:19

Dynamic application security testing, or DAST, is also known as black box testing. DAST scans a deployed application once it enters runtime. The results are based on how the application responds to a series of tests from the outside. These tests aren't language specific and have a lower rate of false positives. The downsides to DASTs are that they're hard to automate, can't pinpoint the exact cause of a flaw, and can take up to a week to complete.

### Interactive Application Security Testing 05:19-06:06

Finally, we have interactive application security testing, or IAST, which can be broken down into two types: passive and active. In passive IAST, we build interactivity into static application security testing. IAST tools are source code scanners that work during runtime.

In active IAST, the testing tools can access interpreters and compliers, allowing precise identification of a problematic line of code during runtime. This speeds up the testing and remediation process. The combination of passive and active IAST can help us in the development stage by catching vulnerabilities early, in the QA stage by adding automated security checkpoints, and in the production stage through continuous monitoring.

### Summary 06:06-06:35

That's it for this lesson. In this lesson, we reviewed two common software development lifecycles: Waterfall and Agile. Then we looked at two different kinds of coding errors: compile errors and runtime errors. We finished up by looking at static, dynamic, and interactive application security testing and how these tools can help us secure applications throughout the development lifecycle.

## 10.4.2 Automation and Scripting

### Automation and Scripting 00:00-00:28

In this lesson, we'll discuss automation and scripting. For companies to be competitive today, they must use automation to help them with testing. Manual testing is important for some situations, but it's time consuming and financially taxing. Automation is helpful because testing can be done without employee oversight. It's faster, has greater scope, and eliminates human error.

### When to Use Automation 00:28-01:08

Even though automation is a very helpful tool, it isn't always the best approach for testing. So when should you use it?

It's best to use automation for tests that are repeatable, time consuming, and complex. Use manual testing for new tests to make sure they function properly before you have them automated. Also use manual testing for tests that change frequently.

The automation process has several steps. Understand that this process is cyclical in nature. This means that steps in this process may be repeated if necessary, and that code can be sent back if test failure occurs along the way. Let's take a closer look.

### Automation Process: Step 1 01:08-01:26

The first step in the automation process is to select the most appropriate automation tool for the task. There are many tools available. Some are commercial and some are open source. Most of them offer a free trial version to give you the opportunity to see which one works best for your project.

### Automation Process: Step 2 01:26-01:38

The next step is to define the testing scope. Here you establish which existing features to test and which features not to test. It's important to define deadlines at this stage.

### Automation Process: Step 3 01:38-01:58

The third step is planning, design, and development. In this stage, you select a design framework. This could be a data-driven framework, a keyword-driven framework, a modular framework, or a hybrid of the three. You also schedule the scripting and execution and define the deliverables.

### Automation Process: Step 4 01:58-02:09

The fourth step is test execution. It's best to test the script and then execute the automation. Reports can be generated from the tests in this stage.

### Automation Process: Step 5 02:09-02:24

The final step is maintenance. Systems are constantly updated and so testing must be updated as well.

There are some key terms and concepts that you should be familiar with that are found throughout the automation process.

### Automated Courses of Action 02:24-03:16

The first concept is automated courses of action, which is a set of automated actions applied to the system. This is part of the development stage. For example, let's say that you're testing a new application feature that should be able to show a details page for a product, an in-stock number for the product, and be able to update the availability database when the product is selected and purchased. You could either create an end-to-end test that goes through the entire customer shopping process, or you could write several atomic tests that each test one step in the process. Either way, you would be simulating hundreds of shoppers and their purchasing choices. Your tests would include shoppers behaving normally, but they would also include how to adapt when a shopper doesn't follow the purchasing steps correctly. These simulated steps are an example of automated courses of action.

### Continuous Integration 03:16-03:44

The next concept is continuous integration, which is the automated process of integrating code created by multiple developers on a single project. This integration normally happens several times a day. Having code from each developer integrated into the core system at regular intervals gives the developers immediate feedback having to do with any errors that arise. This provides continuity and dependability in the code.

### Continuous Delivery 03:44-04:23

Another concept is continuous delivery, which is a process that includes continuous integration, automatic testing, and continuous deployment.

Continuous delivery benefits users and developers because small code updates are tested and released automatically. This gives users timely updates. This also benefits developers because users can give feedback sooner and more often, possibly within hours or days, making the development cycle continuous and fluid.

In continuous delivery, the code is always in a ready state, but its release can be determined manually. So ultimate control over the release lies with the team.

### Continuous Deployment 04:23-05:09

There are situations when an organization chooses to have continuous deployment rather than manual deployment. This means that coding updates are automatically sent to production if the product passes automated tests. This method provides a quick path for the release of dependable products. For this process to work, you need to have the highest quality testing possible. Along the way, feature flagging can help communication across development environments. This allows you to have certain features turned on or off during testing and beyond. Feature flags attach conditions which determine who can see a feature and when. This can narrow deployment risk by having certain features available to a few users without the deployment of new code.

### Continuous Deployment 05:09-05:31

For example, you may want only 2 percent of your customers to try your update on an application that shows available parking spots in a downtown area. With continuous deployment, if the mapping feature is inaccurate or sluggish, only 2 percent of your customers are affected. You get feedback in a timely manner, and your company's reputation is still intact.

### Continuous Validation 05:31-05:49

Next let's talk about continuous validation. Continuous validation takes all the evidence from all the testing that occurred throughout the automation process and creates reports about requirements, functionality, and vulnerabilities. This validation data can help you determine if you're ready for deployment.

### Continuous Monitoring 05:49-06:09

Finally, let's look at continuous monitoring. This can be done throughout the development process to ensure application integrity and security. Continuous monitoring uses feedback and analytics to determine control functionality, error detection, configuration issues, and transaction tracking.

### Summary 06:09-06:42

That's it for this lesson. In this lesson, we reviewed the automation process and specifically looked at automated courses of action, continuous integration, continuous delivery, continuous deployment, continuous validation, and continuous monitoring. By utilizing the automation process throughout development, developers have more liberty to create, more money and time to invest, and an all-around faster production cycle.

## 10.4.3 SDLC and Development Facts

Even though you may not be a software developer, most security professionals at some point work with software engineers who develop applications. And just like any other enterprise component, these applications need to be properly secured.

This lesson covers the following topics:

<ul>
   <li>
    Waterfall development life cycle model
   </li>
   <li>
    Agile development life cycle model
   </li>
   <li>
    Coding errors
   </li>
   <li>
    Security testing methods
   </li>
</ul>

### Waterfall Development Life Cycle Model

The most widely used development model is the Waterfall model. It is called this because each step is completed before the next step is begun so that each step flows to the next.

The Waterfall development life cycle model steps are:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">Step</th>
        <th scope="col" class="fw-bold">Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Requirements</td>
        <td>
        All requirements for the application being developed are gathered
        from the client, user, or stakeholder.
        </td>
    </tr>
    <tr>
        <td>Design</td>
        <td>The software is documented, diagramed, and designed.</td>
    </tr>
    <tr>
        <td>Implementation</td>
        <td>The code is written.</td>
    </tr>
    <tr>
        <td>Testing</td>
        <td>
        A quality assurance team makes sure requirements are met, the code
        works properly across devices, and security issues are noted.
        </td>
    </tr>
    <tr>
        <td>Deployment</td>
        <td>The application is released to a client or to the public.</td>
    </tr>
    <tr>
        <td>Maintenance</td>
        <td>
        The application is monitored for bugs or problems that are patched
        or fixed while in use. This is an ongoing stage that continues
        throughout the life of the app.
        </td>
    </tr>
    </tbody>
</table>

Understand that an application will likely go through some of these steps multiple times before moving to the next step. For example, the application might go through the Design step five times before it’s ready to move to the Implementation step. Or the application may move back from the Implementation stage to the Design stage if a new feature needs to be added.

> This entire development life cycle is a slow process and may take months or years to complete. The Waterfall method also lacks flexibility since the requirements determined in the beginning are carried through to the end product.

![waterfall model](/images/10/waterfall_model.jpg)

### Agile Development Life Cycle Model

A more agile approach was introduced in 2001 that approaches software development as a continuous, changing process with never-ending versions, bug fixes, and enhancements. This approach is aptly named Agile.

The Agile model works in this manner:

<ul>
   <li>
    Breaks development into smaller time frames called Sprints
    <ul>
     <li>
      Each Sprint has a specific duration (usually two to three weeks)
     </li>
     <li>
      Developers work on one feature during a Sprint
     </li>
    </ul>
   </li>
   <li>
    At the end of each Sprint, developers move on to the next feature
   </li>
   <li>
    Testing is performed throughout the development cycle
   </li>
</ul>

![Agile Model](/images/10/agile_model.jpg)

### Coding Errors

Coding errors and design flaws are the main causes of software vulnerabilities. We can categorize these errors into two types:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">
        Coding Error Type
        </th>
        <th scope="col" class="fw-bold">Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Compile</td>
        <td>
        <ul>
            <li>
            An error that occurs during the building or compilation stage
            </li>
            <li>Error compromises the software implementation</li>
            <li>Prevents app from running</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Runtime</td>
        <td>
        <ul>
            <li>An error that occurs while software is running</li>
            <li>Sometimes called bugs</li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

### Secure Testing Methods

During the coding and design phases of development, you can increase development and application security by implementing a few key practices. Integrate security testing into each step in the development process.

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">
        Secure Testing Method
        </th>
        <th scope="col" class="fw-bold">Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Static application security testing</td>
        <td>
        <ul>
            <li>Known as white box testing</li>
            <li>
            Focuses on analyzing source code, binaries, and byte code early
            in development process
            </li>
            <li>
            Good at identifying things like SQL injections and buffer
            overflows
            </li>
            <li>
            Can identify exact cause of a coding problem
            <ul>
                <li>Only in code that's written but not deployed</li>
            </ul>
            </li>
            <li>Language specific</li>
            <li>Can run continually and be widely applied</li>
            <li>Has a high percentage of false positives</li>
            <li>Limited in the types of vulnerabilities it can detect</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Dynamic application security testing</td>
        <td>
        <ul>
            <li>Known as black box testing</li>
            <li>Scans applications after deployment</li>
            <li>Tests from the outside</li>
            <li>
            Uses a series of test to determine vulnerabilities and flaws
            </li>
            <li>Not language specific</li>
            <li>Has fewer false positives</li>
            <li>Hard to automate</li>
            <li>Cannot pinpoint the cause of a flaw</li>
            <li>Can take up to a week to complete the testing process</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Interactive application security testing</td>
        <td>
        Has two types:
        <ul>
            <li>
            Passive
            <ul>
                <li>
                Interactive functionality is built into static application
                security testing
                </li>
                <li>Uses source code scanners during runtime</li>
            </ul>
            </li>
            <li>
            Active
            <ul>
                <li>
                Testing tools can access interpreters and compilers,
                allowing precise identification of a problematic line of
                code in runtime
                </li>
                <li>Speeds up testing and remediation</li>
                <li>
                Can help in the Development stage by catching
                vulnerabilities early
                </li>
                <li>
                Can help in the QA stage by adding automated security
                checkpoints
                </li>
                <li>
                Can help in the Production stage through continuous
                monitoring
                </li>
            </ul>
            </li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

### 10.4.4 Version Control Management

### Version Control Management 00:00-00:45

When you develop an application, the most valuable possession is the source code. Having it protected is critical. In this lesson, we'll discuss version control management as well as provisioning and deprovisioning, which aid in protecting the source code. In application development, there's usually a complex process of writing, revising, and updating the code since multiple developers work together on the same project. There are different ways to approach this reality as this creates a challenge when keeping track of changes in the code. In general, most organizations use a version control system, or VCS, to track these changes.

### Version Control System (VCS) 00:45-01:12

Let's look at how it works. A version control system uses a repository, which is a storage location that holds all the source files used during development. This centralized file system can be accessed by all authorized users. It allows developers to simultaneously work on the same file, revert to older files, and even restore files that were deleted. These repositories are often stored in the cloud or on a third-party website.

### Version Control System Benefits 01:12-01:52

There are many benefits to using a VCS. For one, it has the flexibility to allow for branching and merging. This allows a developer to work on one specific feature in a branch that he or she created, and then merge it back into the source code when ready. It also keeps a history of code changes. This history includes the details of who, what, when, and why. Together with annotations that developers can add, a team can understand why the code was designed the way it was. This also helps prevent incompatibility issues without preventing the developers from continuing their work.

### Provisioning and Deprovisioning 01:52-02:43

Now let's talk about provisioning. Provisioning is the process of giving access to users through privileges and permissions. It's important that developers and others working on a project have access to all the resources they need to do their work. This includes the permissions that you give in the VCS as well as in other areas of your system. It's important to only give permissions for specifically what a user needs and only until he or she no longer needs that access. If he or she moves on to another project, changes roles, leaves the organization, or if the project is complete, be sure to deprovision them. This means that you remove their privileges and permissions. This is the basic idea behind the principle of least privilege, which is important in application development just as it is throughout your organization.

### Summary 02:43-03:06

That's it for this lesson. In this lesson, we discussed important secure coding techniques that include using a version control system to provide continuity, traceability, and protection throughout the development process. We then went over provisioning and deprovisioning as they apply to protecting the source code.

## 10.4.5 Secure Coding Concepts

### Secure Coding Concepts 00:00-00:20

Information is constantly exchanged, and attackers work relentlessly to access this data. This is why it's essential to begin your security efforts at the coding level. In this lesson, I'll go over some important secure coding concepts. Let's start with normalization.

### Normalization 00:20-00:48

Normalization is a method of organizing a database into relational tables in order to reduce redundancy and protect against insertion, update, and deletion anomalies. Larger tables are divided into smaller tables and are linked by relationships. This increases performance because it reduces disk space, provides quick access to data manipulation, and eliminates the need for you to modify data in more than one place.

### Normalization 00:48-01:03

For example, let's say you're working on a library's database, and you only want one data item in each field. You would divide the table to reduce redundancy and use the patron's library card number as the book table's special key.

### Stored Procedures 01:03-02:08

In a similar way, stored procedures also help reduce redundancies and increase security. A stored procedure is one or more database statements that you store as a group in the database's dictionary and use to execute all the statements in the collection when called. Think of it like library books on a shelf. Each book represents a statement or several statements. By storing these grouped statements, you can metaphorically pull a book off the shelf without having to rewrite the book each time. You've centralized the code and eliminated the need to constantly reproduce it. Utilizing stored procedures also helps you keep the program's calling rules consistent across platforms. Most importantly, from a security standpoint, these procedures create a more secure process by protecting the code from users. A user is able to call a stored procedure without seeing the underlying code itself. Think of a user seeing only the book cover, but not the sentences in the book. This also limits injection attacks—it would be hard to write in a closed book.

### Code Obfuscation/Code Camouflage 02:08-02:36

Next, let's look at code obfuscation, or code camouflage. You can protect code through obfuscation, which alters an executable to make reading the code difficult for attackers while remaining fully functional. There are several methods for obfuscating code, and most can eventually be reverse engineered, but it does add one more layer of protection. Anything that makes it harder to debug or manipulate an application is an additional deterrent.

### Code Reuse 02:36-03:19

An unwritten rule among developers is that you shouldn't repeat yourself. There are many times when reusing code just makes sense. If a programmer writes the same code at least three times, it makes sense to create a shared library with that code that everyone has access to. Reusing code can be risky, though, if the code being used isn't secure and gets spread throughout the application. It can also be a problem if the reused code doesn't work well in the new environment or if the changes aren't as secure

as they would have been had the code been written expressly for the purpose at hand. You should reuse code only when it saves you from duplication and it's comprehensively tested so as to not spread faulty logic.

### Dead Code 03:19-03:46

Next, we have dead code, which has more than one definition. Sometimes, dead code refers to code that's non-executable at runtime. Sometimes, it means source code that's executed but not used in any other computation, making it obsolete. It's more secure for you to remove any dead code from your application because dead code leaves an unnecessary opening that could be exploited. If it doesn't exist, it can't be exploited.

### Memory Management 03:46-03:54

Now let's talk about memory management. Preventing access to your memory from would-be attackers is an essential security priority.

### Memory Management 03:54-04:29

The most common memory vulnerabilities are unchecked buffer-copy input size, incorrectly calculated buffer size, and uncontrolled format strings. If unchecked, any of these vulnerabilities can provide opportunities for someone to compromise your application. You can prevent buffer overflow and memory leaks by limiting the character amount a buffer can read. To protect against incorrect buffer size calculations, define constants for the size argument. Also, don't allow user input in format strings, as these can cause information disclosure and malicious code injection.

### Third-Party Libraries and Software Development Kits (SDKs) 04:29-04:50

Next, we have third-party libraries and software development kits, or SDKs. Third-party libraries and SDKs can be a great resource to developers because they can provide code frameworks or code snippets that help move development along faster. Why? Because we don't need to reinvent the wheel.

### Third-Party Libraries and Software Development Kits (SDKs) 04:50-05:38

But there are risks involved anytime you bring in code written by someone outside of your organization. Their code may be taken from someone else's code, and that code may have come from someone else's code, and so on. There may be flaws in the code coming from the original source or anywhere along the line.

Often, programmers use bundles that include much more code than they actually need. Any excessive code can open up vulnerabilities in your program. Also, many SDKs are open source and, as such, there may not be as much urgency to fix bugs since the code passes through so many hands. It belongs to everyone and no one. As a developer, you're ultimately responsible for the code you include in your program, so it's critical that you test the code for functionality and security issues.

### Data Exposure 05:38-05:53

Finally, let's look at data exposure. Sensitive data exposure involves unintended exposure of personal and confidential data. This can come from weak or non-existent encryption, coding flaws, or misapplied database uploads.

### Data Exposure Prevention 05:53-06:31

To prevent data exposure, encrypt data both in transit and at rest by using cryptographic algorithms and keys. You can also disable caching on forms that collect data. Cached forms can contain important personal data or passwords. Not allowing that sensitive information to be held in a temporary file is safer since temporary files might not have the same level of protection as a database. Additionally, you can implement hashing, which converts passwords into another value. You can salt the hashes as well, which means adding extra data to the hashed password, making them even harder to crack.

### Summary 06:31-06:57

That's it for this lesson. In this lesson, we went over normalization, stored procedures, code obfuscation, code reuse, dead code, memory management, third-party libraries, SDKs, and data exposure. You can better protect your code and applications by practicing these secure coding techniques.

## 10.4.6 Application Hardening

### Application Hardening 00:00-00:26

In this lesson, I'll go over application hardening. Applications can have complex code, be written by third parties, and accept user input. Each of these issues can make app security a challenge. So, let's look at some basic hardening techniques.

If you have access to the source code, one security method that's been around for many years is software diversity.

### Software Diversity 00:26-01:08

Software diversity aims to protect code from exploitation through form variation. The code accomplishes the same result, but the form changes. A compiler, or sometimes a multicompiler, applies diversity to the binary. Today, there are some compilers that can be applied even if you don't have access to the source code. This diversity means that an attacker must create an exploit for each variant, which acts as a deterrent because it becomes time-consuming and expensive. Software diversity also minimizes the overall impact if one variant is compromised. If you don't have access to the source code, there are still many steps you can take to harden your applications.

### Remove Unnecessary Applications 01:08-01:22

A simple step is to remove any applications that aren't necessary. Remember, additional software is commonly installed with an operating system. The fewer applications you have, the lower your risk of attack.

### Configure Automatic Updates 01:22-01:40

Next, configure automatic updates for your applications. The software company that produced an application generally creates updates that fix any known vulnerabilities. By setting automatic updates, you have protection for those vulnerabilities as soon as the fixes are available.

### User Input Protection 01:40-02:44

Now let's look at protecting against unwanted user input. One area of attack is known as process spawning. In this type of attack, the hacker uses a trusted application that's already running on the operating system to spawn additional processes. In this way, a new process can bypass safeguards and execute a worm, Trojan, or other malicious file. There are few applications that legitimately need to start other processes to function correctly. Most don't. The best option is to block applications from creating child processes. You can make exceptions for the few that have a need for them.

Another commonly used method of exploitation is to alter applications to create new executable files or to modify existing ones. Most applications don't need to create new executable files or have writeable access to them. You can control access to executable files by making sure that your applications don't have permission to create new executable files or to modify existing ones.

### Protect Operating System Components 02:44-03:09

Next, protect operating system components. In Windows, this means the Windows Registry. Some applications do need to make changes in the registry, so you'll need to decide for each application whether to allow or deny registry access. Do your research and find out which applications need to launch new processes, change executable files, or change operating system components.

### Protect Operating System Components 03:09-03:41

A good example is a Linux server that's running an FTPD and whose purpose is to allow users to upload and download FTP files with an FTP-client service. These files could reside in a unique directory or in the user's home directory. You would need to create an exception that allows this service to create a new executable file. Just be sure to limit where the executable file can be created. For example, you could allow the service to create files in a specific directory, but not in the home directory.

### Log File Monitoring 03:41-04:11

Another key to application hardening is to monitor your log files, as they contain a wealth of information. By monitoring your log files and analyzing the log entries, you might be able to identify an application that's vulnerable or that's in the process of being exploited. For example, you might detect an application that's spawning new processes. Log files contain so much information that it's best to use a log monitoring application to filter unneeded information.

### Application Hardening Methodology 04:11-04:58

By applying these hardening steps, you can develop your own methodology for application hardening in your organization. A good approach is to create application hardening rules that apply to all applications and then to look at any apps that are at higher risk because they accept input from insecure sources. A good example is a web server that processes forms, such as a news, email, or FTP server. Then create specific hardening rules for these at-risk applications. You might need to create exceptions, too.

To determine which exceptions to make, set up the system with no exceptions and monitor your log files for a short time. This should give you the information you need to determine what an application legitimately needs to run properly.

### Summary 04:58-05:15

That's it for this video. In this lesson, we talked about application hardening. We covered software diversity, unneeded apps, automatic updates, user input protection, and log file monitoring.

## 10.4.7 Application Development Security Facts

In our world today, information is exchanged constantly. This means that attackers are working relentlessly to access our data. It is essential that we begin security efforts at the coding level.

This lesson covers the following topics:

- Secure coding concepts

### Secure Coding Concepts

Secure coding concepts include the following:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">Concept</th>
        <th scope="col" class="fw-bold">Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Normalization</td>
        <td>
        Normalization is data reorganized in a relational database with the
        intent to eliminate redundancy by having all related data stored in
        one place. Normalization:
        <ul>
            <li>Increases performance by reducing disk space</li>
            <li>
            Provides quick and efficient access to manipulate the data
            </li>
            <li>Lowers the risk of exploitation</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Stored procedures</td>
        <td>
        Stored procedures are one or more database statements stored as a
        group in a database’s data dictionary. When called, these procedures
        execute all the statements in the collection. Stored procedures:
        <ul>
            <li>
            Centralize the code and eliminate the need to reproduce it
            </li>
            <li>Keep calling program rules consistent across programs</li>
            <li>
            Protect the code from users by allowing the user to call a
            stored procedure without seeing the actual code
            </li>
            <li>Limit injection attacks</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Code obfuscation/code camouflage</td>
        <td>
        Obfuscation is the deliberate act of creating source or machine code
        that is difficult for humans to understand. In other words, the code
        is camouflaged.
        <ul>
            <li>
            Programmers use roundabout expressions to compose statements
            that deliberately obfuscate code to conceal its purpose or its
            logic.
            </li>
            <li>
            They use implicit values embedded in it to prevent tampering,
            deter reverse engineering, or as a puzzle or recreational
            challenge for someone reading the source code.
            </li>
            <li>
            This is usually done with an automated tool but can also be done
            manually.
            </li>
            <li>
            There are several methods, but most can be reverse engineered.
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Code reuse</td>
        <td>
        Code reuse is simply using the same code multiple times. Reusing
        code is a good idea if the programmer writes the same code at least
        three times. Code reuse:
        <ul>
            <li>
            Can create a shared library for others that use the same code
            </li>
            <li>
            Can be a security problem if:
            <ul>
                <li>
                The code is not secure before it is shared and used multiple
                times
                </li>
                <li>
                It has changes made to it to fit a new use, but the changes
                aren't secure
                </li>
            </ul>
            </li>
            <li>
            Be sure to comprehensively test code before allowing reuse
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Dead code</td>
        <td>
        <ul>
            <li>
            Sometimes dead code refers to code that is non-executable at
            runtime
            </li>
            <li>
            Sometimes it means source code in a program that is executed but
            is not used in any other computation, making it obsolete.
            </li>
            <li>
            Remove any dead code from your application for security
            <ul>
                <li>If it doesn't exist, it can't be exploited</li>
            </ul>
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Memory management</td>
        <td>
        Memory management is a resource-management process applied to
        computer memory. It allows your computer system to assign portions
        of memory called blocks to various running programs that optimize
        overall system performance.
        <p>
            <br />
            Memory management resides in the hardware, the operating system,
            programs, and applications. In the hardware, memory management
            involves components that physically store data, such as RAM chips,
            memory caches, and SSDs. In the OS, memory management involves the
            allocation of specific memory blocks to individual programs as
            user demands change. At the Application level, memory management
            ensures the availability of adequate memory for the objects and
            data structures of each running program at all times.
            <br />
            <br />
            When the program requests a block of memory, the allocator in the
            memory manager assigns that block to the program. When a program
            no longer needs the data in the previously allocated memory
            blocks, those blocks become available for reassignment. This task
            can be done automatically by the memory manager or manually by the
            programmer.
        </p>
        <ul>
            <li>
            Most common memory vulnerabilities:
            <ul>
                <li>Size of input in buffer copy not checked</li>
                <li>Buffer size calculated incorrectly</li>
                <li>Format string not controlled</li>
            </ul>
            </li>
            <li>
            To prevent vulnerabilities:
            <ul>
                <li>Limit the amount of characters read into the buffer</li>
                <li>Define constants for the size argument</li>
                <li>Do not allow user input in format strings</li>
            </ul>
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Third-party libraries and software development kits (SDKs)</td>
        <td>
        A third-party library is a library where the code is not maintained
        in house. A software development kit (SDK) is a set of software
        development tools that can be installed as one unit. Both can
        provide code frameworks or code snippets to help development go
        faster. Though they can be very helpful, there are risks involved.
        For example:
        <ul>
            <li>
            Anytime code comes from an outside source there is risk that it
            may contain flaws and vulnerabilities
            </li>
            <li>
            Sometimes code comes in bundles, giving developers more code
            than they need
            <ul>
                <li>
                Extra code can create extra opportunity for exploitation
                </li>
            </ul>
            </li>
            <li>
            SDKs are often open-source and, as such, there may be no urgency
            to fix bugs
            </li>
        </ul>
        <p>
            Be sure to test code from third-party libraries and SDKs for
            functionality and security issues.
        </p>
        </td>
    </tr>
    <tr>
        <td>Sensitive data exposure</td>
        <td>
        Sensitive data exposure involves unintended exposure of personal and
        confidential data. This can come from:
        <ul>
            <li>Weak or missing encryption</li>
            <li>Coding flaws</li>
            <li>Misapplied data uploads in a database</li>
        </ul>
        <p>To mitigate sensitive data exposure:</p>
        <ul>
            <li>
            Encrypt data in transit and at rest using cryptographic
            algorithms and keys
            </li>
            <li>Disable caching on forms that collect data</li>
            <li>Implement hashed and salted passwords</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Fuzz testing</td>
        <td>
        Fuzz testing (also known as fuzzing) is a software testing technique
        that exposes security problems by providing invalid, unexpected, or
        random data to the inputs of an application. Fuzzing program types
        are:
        <ul>
            <li>
            Mutation-based
            <ul>
                <li>Mutate existing data samples to create data</li>
            </ul>
            </li>
            <li>
            Generation-based
            <ul>
                <li>Define new test data based on models of the input</li>
            </ul>
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Code signing</td>
        <td>
        Code signing is the process of digitally signing (encrypting)
        executables and scripts to confirm the software author and guarantee
        that the code has not been altered or corrupted since it was signed.
        The process employs the use of a cryptographic hash to validate
        authenticity and integrity.
        <p>Code signing:</p>
        <ul>
            <li>Provides security when deployed</li>
            <li>
            Helps prevent namespace conflicts in some programming languages
            </li>
            <li>
            Provides a digital signature mechanism to verify the identity of
            the author or build system
            </li>
            <li>
            Provides a checksum to verify that the object has not been
            modified
            </li>
            <li>
            Provides versioning information about an object, or is used to
            store other metadata about an object
            </li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

### 10.4.8 Hardening Applications on Linux

### Hardening Applications on Linux 00:00-00:18

In this demonstration, we're going to look at how to harden applications or services on a Linux system. There are several different services you can use to harden applications or services. One of them is called SELinux. It's a cool access control security feature.

### SELinux 00:18-02:18

Essentially, the idea behind SELinux is that you use the operating system kernel to limit what a particular application is allowed to do, and it goes beyond the limitations that you set with permissions or privileges based on the user account. Think of it as a roadblock to help prevent hackers from doing more damage.

SELinux can be set to determine access between users, files, directories, memory, ports, and sockets. First, we're going to type ‘sestatus'. this will tell us if SELinux is enforcing the system. Next, we'll take a look at the SELinux config file located in ‘/etc/selinux/config'. This config file sets the permanent state of SELinux. It's recommended to set your system to permissive first, install all your needed applications, and then view the logs to make the necessary changes to SELinux. The permissive setting logs all the permission denied errors while allowing an application to run. Any changes to the SELinux config file located in /etc/selinux/config requires a reboot.

Two places we can look for SELinux permission denied errors are in the audit log and journalctl. Let's take a look at the audit log, ‘less /var/log/audit/audit.log'. We're going to use a question mark and search for ‘AVC', which is a type of SELinux error. As you can see, there's some denied messages from other applications that we should probably look at. Let's exit out of here and look at ‘journalctl'. SELinux errors may be in red if there's a problem to address. We don't have much time to search through the logs right now, but this should give you a good idea of where to look.

If a service is unable to start, it might cause SELinux to deny permission to certain aspects that allow the application to run. When you need to determine the cause of a problem, logs are your friend. Let's type ‘clear' to clear our screen.

### Booleans 02:18-03:12

By default, SELinux has hundreds of Booleans that are essentially off and on switches for certain tasks. To view the whole list of Booleans, type ‘getsebool -a'. Let's say I only want to see Booleans related to samba. Let's type ‘getsebool -a | grep samba'. To enable a Boolean, we can use the setsebool command. There's one in particular that we want to enable called samba_share_nfs. This one grants samba rights to export NFS volumes. To set this, type ‘setsebool samba_share_nfs 1 -P'. Now, if we go back and type ‘getsebool -a | grep samba', you'll see that samba_share_nfs is set to On.

### Context Types 03:12-04:08

When SELinux is enforced, it uses a categorization system called context types. These are labels with addition information related to its purpose, user, role, and such. Today, we're just going to cover the basics. One useful command you can use to view the context type is the -Z flag. Let take a look at the context types for the samba configuration folder. Type ‘ls -lZ /etc/samba'. As you can see, there's additional information listed here that gives a label to samba so SELinux knows these are samba configuration files. If a configuration file was made in a /home directory and then copied to an /etc config directory, it may not have the right context type when copied. This could prevent applications from working correctly and show a denied message from SELinux in the logs.

### Summary 04:08-04:31

And that's it for this demonstration. In this demo, we looked at hardening Linux applications using SELinux. We talked about how SELinux can protect your system using access control security. Then we saw some of the commands for managing SELinux and how to troubleshoot permission denied errors from SELinux.

## 10.4.9 Implementing Application Whitelisting with AppLocker

### Implement Application Whitelisting with AppLocker 00:00-00:21

In this demonstration, we'll practice implementing application whitelisting using Applocker. AppLocker is a very useful feature of Windows.

You can use it to accomplish such things as preventing malware from being installed, preventing unsupported applications from being installed, etc.

### Whitelist an Application 00:21-01:24

The process of implementing application whitelisting is fairly complex.

First, you must implement the rules for executable files. Then, you test those rules to verify that they are working as you expect without negatively affecting users.

After you analyze events created by AppLocker, you can then modify the rules and enforce them.

Let's begin with the first step of defining the executable rules. In this scenario, we'll enforce the AppLocker policy settings using Group Policy.

By doing this, anytime a user logs into the domain, the AppLocker settings are automatically enforced. Let's open the Group Policy Manager.

Notice here we have the Default Domain Policy that's linked to the DEMO domain. We want to enforce these AppLocker policy settings throughout the entire network.

The default domain policy would be a good choice of Group Policy objects (GPOs) to use. Let's right-click it and select Edit. We're going to resize this screen so we can see what's going on a little better.

### Configure Rule Enforcement 01:24-02:26

Under Computer Configuration, we'll expand Policies > Windows Settings > Security Settings > Application Control Policies.

When we expand AppLocker, we can see these sets of application rules we can use. Let's select AppLocker and click Configure rule enforcement.

For our purposes today, we'll focus on Executable rules. We'll select the Configured checkbox here. After that we need to define whether we want to enforce those rules or just audit them.

We'll choose to audit only for now. You could immediately enforce the rules if you wanted, however, in a production environment you want to make sure that the rules you define work properly for the end users in the organization.

In other words, you want to make sure the users can open their applications and use them the way they're supposed to.

When we select Audit, the events are generated by AppLocker and we can access those in Event Viewer. We can analyze Event Viewer events to decide whether the rules are working correctly or whether we need to modify them.

### Create a New Rule 02:26-02:55

Let's go to Executable Rules. Notice that there are no rules here. We're enforcing them, but there are no rules to enforce. So, let's right-click here and select Create New Rule.

In the Before You Begin screen, it tells you how the rule works and some preparatory steps you need to follow.

For example, you need to make sure that the applications you want to create the rule for are installed on this system. We've already done that. There are other steps, but we don't need to worry about them. Let's click Next.

### Set Permissions 02:55-03:40

Now we have to specify the action to be used in the AppLocker rule. As noted up here, an allow action permits the affected files to run.

A deny action, on the other hand, prevents the files from running. We want to use an Allow rule. Another thing we do on this page is specify who this rule applies to.

The application we are allowing is called SalesBuilder. It's used by the Sales department. As such, we want this rule to apply only to the Sales group.

So, let's specify that this rule applies to the Sales group by clicking Select. Then we'll click Advanced and search for the Sales group. There it is. Double-click it and click OK. Click Next.

### Specify Conditions and Path 03:40-04:31

At this point, we need to specify the primary condition that will be used in the rule. We have three options. We'll use the Path option.

We would use the Publisher option if the application we want to create the rule for is signed by a known software publisher, but since ours is an in-house application that isn't signed, we can't' use that option. Let's click Next.

Now we need to specify the path to the application. We'll click Browse Folders and let's browse to the folder where the executable resides. It's SalesBuilder; select it. Notice that we have two options for specifying a path.

We can specify a file or specify a folder. Because we want the rule to apply to all files in the SalesBuilder folder, we specified a folder instead of a file. Click Next. We don't want to create any exceptions. We'll use the default name for the rule.

### Create Default Rules 04:31-05:30

Notice that we're presented with this dialogue here. It tells us that we've created a custom rule, but there are default rules that should be created so that important system files will still be able to be run.

If you don't create these default rules, you may not be able to run most of the applications that you need. Let's create the default rules along with the rule we just defined by clicking Yes.

And there you go. Notice that the default rules allow basically full access to anyone in the administrator's group.

The Everyone group is allowed access to all files located in the Windows folder and it is also allowed access to files that are installed in the Program Files folder.

We had to create this custom rule because SalesBuilder is not installed in the Program Files folder. It's installed in the root directory of the C: drive. We created a special rule that allows the Sales group to run the application.

Let's go ahead and close the Group Policy Management Editor. Let's make sure the Default Domain Policy is being enforced, which it is.

Start Application Identity Service Automatically 05:30-07:02
It's important to know that the rules we just configured won't be applied to any users who are currently logged in while we defined these rules.

The rules won't take effect until those users log out and log back in, or until you run GPUpdate on the workstation.

Now, it's important to note that AppLocker uses the Application Identity service on individual workstations to verify the attributes of the executable files we specified in our executable rules. Therefore, we need to make sure that the Application Identity service is always started by default. We can do this using Group Policy.

By doing this when the user logs into the domain, we enforce the AppLocker rules and we make sure that the Application Identity service automatically runs as well.

So, let's edit our default domain policy again. We'll go to Computer Configuration > Policies > Windows settings > Security Settings.

Under Security Settings let's select System Services. Over here in the right pane, we'll right-click Application Identity. And then we'll define this to start automatically. Click OK.

With the rules configured and the Application Identity service starting automatically, we can test our AppLocker policy. We can have end users log in to the domain, run the application as they normally would, and then we analyze the AppLocker events.

Based on what we see in Event Viewer, we would decide whether the rules we set up are functioning correctly. If they are, we can enforce the policy. If not, we would go in and modify the policy to work the way it should.

### Summary 07:02-07:21

That's it for this demonstration. In this demo, we talked about implementing application whitelisting with AppLocker.

We enabled AppLocker enforcement, created a custom rule, added default rules, and then configured the Application Identity service to start automatically.

## 10.4.11 Implementing Data Execution Preventions

### Implementing Data Execution Prevention (DEP) 00:00-00:28

In this demonstration, we're going to practice working with Data Execution Prevention, or DEP.

DEP is a set of hardware and software technologies designed to prevent malicious code from running on a Windows system.

DEP looks for and blocks a malicious program or any other type of attack that has injected a process with malicious code and is trying to run that code. Let's take a look at how this works.

### Enable DEP on a Windows System 00:28-01:26

Let's start with a Windows system. If I right-click Start, select System, go to System info, come over to Advanced system settings, go to Performance Settings on the Advanced tab, and then go to the Data Execution Prevention tab, we can see that DEP is only enabled for essential Windows programs and services by default.

That's fine. But to increase system security, you may want to ramp that up a bit by turning on DEP for all programs and services.

Be aware that if you do this, it's possible that you could end up with a false positive. This means that DEP thinks a legitimate process that's running on the system is malicious and shuts it down.

This is particularly relevant in situations where you have in-house programmers who create custom applications for your organization.

In-house developed applications sometimes aren't as rigorously tested, so they might kick off an exception where DEP detects them and thinks that they're malicious code.

### Identify DEP Exceptions 01:26-02:30

But notice you do have the option to turn off DEP for specific applications. We have a case where we can do that on this system.

I'm going to come down here to File Explorer. If I go to my C: drive, then into Program Files, and then to the SalesBuilder folder, there's an application called SalesBuilder.

This is an in-house written application. It wasn't extensively tested and will kick off an exception when we try to run it if DEP is monitoring all system processes.

What we need to do is go back over here and select Turn on DEP for all programs and services except those I select and add SalesBuilder.

Let's hit Add and go to `Program Files > SalesBuilder > SalesBuilder.exe`. Now DEP is turned on for everything except SalesBuilder. We hit Apply. We do have to restart the computer to finalize the process. We click OK, close everything down, and reboot.

### Verify that DEP is Enforced 02:30-03:10

DEP is now enforced. We can check our settings over here by going to `System > System info > Advanced system settings > Performance Settings > Data Execution Prevention`. DEP is now on for all services except SalesBuilder.

This means that whenever a process is run on this system, whether it's a service or application, DEP will watch it and look for any instance where it's trying to run code from places that it shouldn't. Except, of course, for the one application that I specified earlier, SalesBuilder, which DEP was told not to worry about because I know that I trust it.

### Summary 03:10-03:37

That's it for this demonstration.

In this demo, we looked at using Data Execution Prevention, or DEP. We talked about what DEP is and why it's useful.

We enabled it on a Windows client system and configured it so that it would ignore an in-house developed application that would trigger a DEP exception. We want this because we know that it's not a threat and should be ignored.

## 10.4.13 Hardening Applications Facts

Application hardening is the process of preventing the exploitation of vulnerabilities in software applications. Applications pose the most difficult security challenges for a security administrator because they are complex, usually developed by a third party, and designed to accept input from users.

This lesson covers the following topics:

- Application hardening guidelines
- Application hardening techniques

### Application Hardening Guidelines

Basic hardening guidelines for applications are as follows:

<ul>
   <li>
    Assume all installed applications are flawed
   </li>
   <li>
    Remove all unused applications from the system
   </li>
   <li>
    Limit administrative privileges
   </li>
   <li>
    Install security software, such as antivirus, anti-spyware, and anti-rootkit software
   </li>
   <li>
    Use firewalls, content filters, and operating system user-authentication 
	features
   </li>
   <li>
    Restrict access to the application and provide access only to those who need it
   </li>
   <li>
    Update all applications with the latest patches when security bulletins are released
   </li>
   <li>
    Identify baselines
   </li>
</ul>

### Application Hardening Techniques

Additional application hardening includes the following techniques:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">
        Technique
        </th>
        <th scope="col" class="fw-bold">Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Block process spawning</td>
        <td>
        Process spawning is the creation of a new process (also called a
        child process) by an existing process (also called a parent
        process). If you take the process spawning ability from the
        application, threat agents are not able to perform process spawning
        attacks.
        </td>
    </tr>
    <tr>
        <td>Control access to executable files</td>
        <td>
        Executable files should be protected from modification by removing
        the Write permissions given to applications.
        </td>
    </tr>
    <tr>
        <td>Protect OS components</td>
        <td>
        Sensitive file system areas (such as Windows Registry keys) should
        be protected by removing Write permissions given to specific
        applications. In most cases, applications do not need to modify
        sensitive areas of the system for them to properly function.
        </td>
    </tr>
    <tr>
        <td>Use exception rules</td>
        <td>
        Exception rules allow an administrator to bypass a specific
        hardening rule when an application has a legitimate need.
        Administrators should exercise caution and set parameters regarding
        the exception that ensure the security of the system.
        </td>
    </tr>
    <tr>
        <td>Monitor logs</td>
        <td>
        Reviewing monitor logs allows an administrator to identify
        potentially vulnerable applications and identify if an application
        is being exploited. The best way to determine exception rules is to
        let the application run without any exceptions and then review the
        monitor logs to determine what an application legitimately needs to
        do.
        </td>
    </tr>
    <tr>
        <td>Use Data Execution Prevention</td>
        <td>
        Data Execution Prevention (DEP) is a security feature that can help
        prevent damage to your computer from viruses and other security
        threats. DEP ensures that applications use computer memory safely.
        DEP closes an application and notifies the administrator if a
        program initiates run instructions from the portion of memory used
        for data.
        </td>
    </tr>
    <tr>
        <td>Implement third-party application hardening tools</td>
        <td>
        Third-party application hardening systems are developed for specific
        applications. The rules used by the application hardening system can
        be applied to the application being hardened, including libraries
        and SDKs. An example of these tools is AppArmor for Linux systems.
        </td>
    </tr>
    </tbody>
</table>
