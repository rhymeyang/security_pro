---
lang: zh-CN
title: Section 10.1 Data Transmission Security
description: some description
---

As you study this section, answer the following questions:

<ul>
    <li>
     How does SSL verify authentication credentials?
    </li>
    <li>
     What protocol is the successor to SSL 3.0?
    </li>
    <li>
     How can you tell that a session with a web server is using SSL?
    </li>
    <li>
     What is the difference between HTTPS and S-HTTP?
    </li>
    <li>
     What does it mean when HTTPS is stateful?
    </li>
    <li>
     What is the difference between IPsec tunnel mode and transport mode?
    </li>
   </ul>

In this section, you will learn to:

<ul>
    <li>
     Add SSL to a website.
    </li>
    <li>
     Allow SSL connections.
    </li>
    <li>
     Require IPsec for communications.
    </li>
   </ul>

The key terms for this section include:

<table class="terms">
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">Term</th>
        <th scope="col" class="fw-bold">Definition</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Secure Sockets Layer (SSL)</td>
        <td>
        A protocol that secures messages being transmitted on the internet.
        </td>
    </tr>
    <tr>
        <td>Transport Layer Security (TLS)</td>
        <td>
        A protocol that secures messages being transmitted on the internet.
        It is the successor to SSL 3.0.
        </td>
    </tr>
    <tr>
        <td>Secure Shell (SSH)</td>
        <td>
        A protocol that allows for secure interactive control of remote
        systems.
        </td>
    </tr>
    <tr>
        <td>
        Hyper Text Transfer Protocol
        <br />
        Secure (HTTPS)
        </td>
        <td>
        A secure form of HTTP that uses either SSL or TLS to encrypt
        sensitive data before it is transmitted.
        </td>
    </tr>
    <tr>
        <td>
        Secure Hypertext Transfer
        <br />
        Protocol (S-HTTP)
        </td>
        <td>
        An alternate protocol that is not widely used because it is not as
        secure as HTTPS.
        </td>
    </tr>
    <tr>
        <td>Internet Protocol Security (IPsec)</td>
        <td>
        A set of protocols that provides secure data transmission over
        unprotected TCP/IP networks.
        </td>
    </tr>
    <tr>
        <td>Authentication Header (AH)</td>
        <td>
        A protocol within IPsec that provides authenticity, non-repudiation,
        and integrity.
        </td>
    </tr>
    <tr>
        <td>Encapsulating Security Payload (ESP)</td>
        <td>
        A protocol within IPsec that provides all the security of AH plus
        confidentiality.
        </td>
    </tr>
    <tr>
        <td>Security Association (SA)</td>
        <td>
        The establishment of shared security information between two network
        entities to support secure communications.
        </td>
    </tr>
    </tbody>
</table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">Exam</th>
        <th scope="col" class="fw-bold">Objective</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>TestOut Security Pro</td>
        <td>
        2.0 Physical and Network Security
        <p>2.2 Harden Network Devices</p>
        </td>
    </tr>
    <tr>
        <td>CompTIA Security+ SY0-601</td>
        <td>
        2.1. Summarize secure application development, deployment, and
        automation concepts.
        <ul>
            <li>
            Secure Sockets Layer (SSL)/Transport Layer Security (TLS)
            inspection
            </li>
        </ul>
        3.1. Given a scenario, implement secure protocols.
        <ul>
            <li>
            Protocols
            <ul>
                <li>Domain Name System</li>
                <li>Security Extension (DNSSEC)</li>
                <li>SSH</li>
                <li>Secure/multipurpose Internet</li>
                <li>mail exchanger (S/MIME)</li>
                <li>Secure real-time protocol (SRTP)</li>
                <li>LDAPS</li>
                <li>File transfer protocol, secure (FTPS)</li>
                <li>Secured file transfer protocol (SFTP)</li>
                <li>
                Simple Network Management Protocol, version 3 (SNMPv3)
                </li>
                <li>Hypertext transfer protocol over SSL/TLS (HTTPS)</li>
                <li>IPsec</li>
                <li>
                Authentication header (AH)/Encapsulated security payload
                (ESP)
                </li>
                <li>Tunnel/transport</li>
                <li>
                Secure post office protocol (POP)/Internet message access
                protocol (IMAP)
                </li>
            </ul>
            </li>
            <li>
            Use cases
            <ul>
                <li>Voice and video</li>
                <li>Time synchronization</li>
                <li>Email and web</li>
                <li>File transfer</li>
                <li>Directory services</li>
                <li>Remote access</li>
                <li>Domain name resolution</li>
                <li>Routing and switching</li>
                <li>Network address allocation</li>
                <li>Subscription services</li>
            </ul>
            </li>
        </ul>
        3.3. Given a scenario, implement secure network designs.
        <ul>
            <li>
            Penetration testing
            <ul>
                <li>IPSec</li>
                <li>SSL/TLS</li>
            </ul>
            </li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

## 10.1.1 Secure Protocols

### Secure Protocols 00:00-00:16

Let's spend a few minutes talking about cryptographic protocols. We're first going to look at Secure Sockets Layer, or SSL. Then we'll discuss its newer version, Transport Layer Security, or TLS.

### Secure HTTPS 00:16-01:17

Both SSL and TLS are cryptographic protocols that provide security for TCP/IP communications. Many application protocols use SSL specifically for secure communications. But both can be used to secure HTTP, which is the protocol meant for requesting and transmitting files over the internet. The problem is that HTTP sends data in cleartext, and these transmissions need to be secure.

Let's say you want to buy a book online from an e-commerce website. You send them some type of payment information, which is most likely a credit card number. If you use HTTP, your credit card number, name, and address are all broadcast as cleartext over the internet. This information is all an identity thief needs to steal your identity as well as the contents of your bank account.

Using SSL or TLS, you can encrypt the HTTP communications so that they're indecipherable to anyone who doesn't have the decryption keys.

### Secure LDAP 01:17-02:00

SSL and TLS can provide encryption for Lightweight Directory Access Protocol, or LDAP, and File Transfer Protocol, or FTP. LDAP is a protocol used to access directories from services which store sensitive authentication information like Active Directory, eDirectory, and OpenLDAP. This information is transmitted over a network in cleartext unless an encryption protocol is applied. Likewise, FTP needs a protocol like SSL or TLS to encrypt FTP communications or your files and authentication is sent in cleartext as well.

An SSL or TLS session typically has a server system and a client system.

### Certificates 02:00-02:35

To use SSL or TLS, you encrypt the communications in that session. The server must have a certificate issued by an e-certificate authority. It could be issued by trusted certificate authorities such as Ntrust, or it could be minted by your own in-house certificate authority.

Either way, you're encrypting the communications between the client and the server using SSL or TLS. The use of a certificate issued by an e-certificate authority indicates asymmetric encryption and the use of public keys between the client and the server.

### SSL and TLS Versions 02:35-03:09

It's important to understand that TLS is a successor to SSL. It was designed to be more secure, though not backwards compatible with SSL. TLS is an application-independent encryption mechanism. In other words, the application that needs the encryption decides the best way to initiate the TLS handshake process. Also, TLS uses Diffie-Hellman to establish the session key, which the client and server use for the duration of the session.

This process of establishing an SSL tunnel is known as the SSL handshake.

### SSL/TLS 03:09-05:43

An SSL or TLS session begins when a client initiates a secure connection with the server. The client sends a special message to the server called a client hello message. The client hello message specifies the highest SSL or TLS protocol version that it supports. It also contains a random number, a list of suggested ciphers, and compression methods. When the server receives the client hello message, it responds with a message called a server hello. The server hello message contains the chosen protocol version, another random number, a selected cipher, and a selected compression method. All these are chosen from the list that was offered initially by the client hello message.

The chosen protocol version is the highest common version that both support. For example, if the client supports TLS 1.0 and the server supports TLS 1.2, they settle on TLS 1.0. The server then sends a message to the client called the certificate message. Then the server sends another message to the client called the server hello done message which indicates that the server is done with the negotiation phase. Once the client knows that the server is done, it responds with a client key exchange message.

Both the client and server use the random number that they sent each other to compute a common secret, which is called the master secret. At this point, all other data for the connection is derived from the master secret. The client sends a changed cipher spec message that says to the server, —œEverything that I'm going to be sending you from now on will be encrypted.—

After that, the client informs the server that it's done by sending it a finished message. The finished message contains some important information like a hash and MAC. The server receives the hash and MAC and attempts to decrypt this finished message and verify it. If it fails to decrypt the message, the handshake is considered to have failed and the connection is ended.

But, if it is able to decrypt the message and verify the hash and MAC, the server responds to the client with a change cipher spec message. This says to the client, —œEverything coming from me will now be encrypted.— The server then sends a finished message. Just as the finished message from the client had a hash and MAC, the finished message from the server also contains both. If they pass verification from the server, the SSL or TLS handshake is considered to be complete.

### DNS Security 05:43-06:37

Another often overlooked vulnerability is DNS security. DNS is like a phone book for the internet. It takes names that people can remember and converts them to IP addresses that couldn't conceivably be memorized by humans. The problem is that DNS queries and responses are transmitted in cleartext by default. This means that anyone could intercept the information during transmission, including someone with malintent.

For example, a hacker could send false information to a DNS server with the knowledge that the server will cache it to make for faster connections in the future. When this happens, the server is considered poisoned. Once poisoned, it may direct traffic to the attacker's website, which can be made to look like the site the user was trying to reach originally. So, the user is unaware that he or she is on a dangerous website and may share sensitive information.

### DNS Protection 06:37-07:20

To protect against this risk, you may employ a standard of encryption called DNS over TLS, or DoT. DoT encrypts DNS queries through the TLS protocol by adding an encryption layer to TCP.

An alternate approach is to implement DNS over HTTPS, or DoH. With this approach, both the queries and the responses are encrypted. DoH adds security by having the traffic flow integrated with HTTP or HTTP/2 traffic instead of through UDP. In this way, the queries and responses are meshed with regular internet traffic flow, making it difficult for an attacker to single out requests and responses.

### Summary 07:20-07:46

That's it for this lesson. In this lesson, we talked about the roles of SSL and TLS. We broke down how SSL handshakes work and took a closer look at some specifics regarding TLS. We finished with how TLS can help secure your DNS server with DNS over TLS and DNS over HTTPS.

## 10.1.2 Secure Protocols 2

### Secure Protocols 2 00:00-00:21

In this lesson, we'll look at implementing SSL and TLS to secure communications between two hosts using common network protocols. We'll also review security implications associated with SSL and TLS. Let's begin with an HTTP session.

### HTTP Function 00:21-01:41

HTTP stands for HyperText Transfer Protocol. HTTP is a cleartext and stateless protocol used to transmit data between a web server and a web browser. This means that the server stores no information about a session and none of the communication is encrypted. Each query is treated as an individual request. This works great if users are just browsing web pages, but there are situations where servers absolutely need to have secure communications.

An example is an e-commerce website that uses shopping carts. HTTP can't track users putting items in a shopping cart because that information must be stored by the client. We fix this tracking issue with cookies, which are simple text files that the server uses for the client.

First, a stateless connection over port 80 is established between the client and server. The server then sets a cookie on the client. When the end user places an item in a shopping cart, the cookie is modified with that information. Each time the file is updated, the cookie information is automatically sent to the server.

The second issue with HTTP is security. HTTP uses cleartext transmissions, and users don't want to transmit sensitive information this way.

### HTTPS Security 01:41-02:08

A common way to secure HTTP is to use HTTPS, which establishes a secure channel between the web client and the web server using either SSL or TLS protocols. The URL for a secure website starts with HTTPS instead of just HTTP.

HTTPS is a stateful connection between the client and server. Each session remains in effect until the communications are complete.

### HTTPS Process 02:08-02:41

With HTTPS, the client contacts the web server which responds by sending a copy of its SSL certificate. The client then verifies three things on the certificate. First, it verifies that the date hasn't expired. Second, the client makes sure the name on the certificate matches the URL that was typed into the browser. Most web browsers automatically warn you if there's a mismatch between the URL and the certificate. Third, the client inspects the certificate to establish its trustworthiness.

### Certificate Authorities 02:41-03:34

There are two categories of certificates that are issued by certificate authorities, or CAs. The first are called trusted CAs because they come from reputable organizations that appear on most browser's pre-configured trusted lists. When a certificate comes from a trusted CA, has a valid date, and the certificate matches the URL, the browser automatically establishes a stateful connection.

The second category is untrusted CAs. Surprisingly, most server operating systems have a built-in certification service that you can use to issue your own certificates. Because almost anyone can issue a certificate, if an organization isn't on the browser's trusted CA list, it won't automatically trust it. Instead, the browser will send the user a warning message. It's then up to the user to decide if the CA is trustworthy.

### Verifying an HTTPS Site 03:34-04:08

The user has two options for verifying that the website is secure. First, he or she can look in the URL address bar to confirm that the address begins with HTTPS://. Second, he or she can look for a lock icon in the URL address bar. To view the site's certificate, right-click the lock icon. Also, please note that HTTPS runs on port 443 instead of port 80. So, be sure your firewall is configured to allow traffic through port 443.

### SSL End-to-End Encrypted Tunnel 04:08-04:52

Let's review some security vulnerabilities with HTTPS. SSL provides an end-to-end encrypted tunnel that's nearly impossible to monitor. This is a concern for security administrators because embedded attacks within the tunnel can slide by your security software undetected. Because the SSL tunnel hides the data, users can establish an HTTPS connection with a web server and access its content even if the content doesn't conform to their organization's acceptable use policy. The tunnel provides an easy path for malware to pass through undetected and infect the client workstation. It even hides the content from network-based anti-malware appliances.

### SSL Inspection 04:52-06:08

For security administrators, SSL inspection can help protect against this threat. This mechanism decrypts the contents of an SSL session, scans the content, repackages the SSL session, and then sends it to the end user. SSL inspection works in the same way that a man-in-the-middle attack, or MITM attack, does.

First, the client tries to establish an HTTPS session with the web server. But the client is configured to go through an SSL inspection-capable proxy server. The client attempts to set up an SSL tunnel to the HTTPS website, but the tunnel is established with the proxy server instead. The proxy server then establishes its own SSL tunnel with the destination server. Neither the web server nor the client know that they aren't connected to each other. The connection from the client to the server is actually going through the proxy server which is running the SSL inspection software. While this process can help prevent attacks to your network, adding a stop in the tunnel with decryption can add a new area of vulnerability. So it's important to implement SSL inspection correctly and to be sure that your cryptography is up to date.

### Summary 06:08-06:33

That's it for this lesson. In this lesson, we looked at common ways that SSL and TLS can be implemented with a protocol such as HTTPS to secure communications between a client and a server. We covered how HTTPS works and then reviewed several security issues to be aware of when working with SSL and TLS.

## 10.1.3 Secure Protocol Facts

Many protocols created in the past were designed with few to no security controls. An unsecured protocol is one that does not provide authentication or encryption, or one that uses plaintext for passing authentication information or data. Newer protocols with security controls include Secure Socket Layer (SSL), Transport Layer Security (TLS), Secure Shell (SSH), HyperText Transfer Protocol (HTTP), and HyperText Transfer Protocol Secure (HTTPs).

This lesson covers the following topics:

<ul>
   <li>
    SSL, TLS, and SSH
   </li>
   <li>
    HTTPS and S-HTTP
   </li>
</ul>

### SSL, TLS, and SSH

Security services (authentication and encryption) are often added to new or existing protocols using one of the following secure protocols:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">
        Protocol
        </th>
        <th scope="col" class="fw-bold">Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Secure Sockets Layer</td>
        <td>
        Secure Socket Layer secures messages being transmitted on the
        internet.
        <p>SSL:</p>
        <ul>
            <li>
            Uses the SSL Handshake Protocol to establish a secure channel.
            </li>
            <li>
            Requires the server to have a certificate issued by a CA and
            uses asymmetric encryption. The handshake process is as follows:
            <ol>
                <li>
                The client checks the server's certificate validity period.
                The authentication process stops if the current date and
                time fall outside of the validity period.
                </li>
                <li>
                The client compares the name on the certificate with the
                name on the URL.
                </li>
                <li>
                The client verifies that the issuing Certificate Authority
                (CA) is on its list of trusted CAs.
                </li>
                <li>
                The client uses the CA's public key to validate the CA's
                digital signature on the server certificate. If the digital
                signature can be verified, the client accepts the server
                certificate as a valid certificate issued by a trusted CA.
                </li>
                <li>
                A session key is used between the client and the server for
                the duration of the SSL session.
                </li>
                <li>
                To protect against man-in-the-middle attacks, the client
                compares the actual DNS name of the server to the DNS name
                on the certificate.
                </li>
                <li>
                If all checks are successful, the client continues with the
                SSL handshake process.
                </li>
            </ol>
            </li>
            <li>
            Uses RSA or the Key Exchange Protocol (KEA) for secure
            exchanging of encryption keys.
            </li>
            <li>Operates at the Session layer (Layer 5) of the OSI model.</li>
            <li>
            Uses port 443 for encrypted traffic. Most firewalls allow port
            443 traffic even when other traffic is blocked. For this reason,
            technologies that can use SSL are more likely to be allowed
            through firewalls than technologies that require other ports to
            be opened.
            </li>
            <li>
            Has different versions. Later versions are more secure. Secure
            Sockets Layer (SSL) 3.0 was the final SSL version.
            </li>
            <li>
            Employs session keys in 40-bit, 56-bit, 128-bit, and 256-bit
            lengths.
            </li>
            <li>
            Provides an end-to-end encrypted tunnel that is almost
            impossible to monitor, scan, or sniff.
            <ul>
                <li>The advantage is that it increases security.</li>
                <li>
                The disadvantages are that:
                <ul>
                    <li>
                    Security software cannot detect embedded attacks in
                    transit.
                    </li>
                    <li>
                    Internal users can use SSL to bypass proxy servers or
                    internet content-filtering systems that have been set up
                    by organizations to control internet usage and content.
                    </li>
                </ul>
                </li>
                <li>
                SSL inspection uses security software on a proxy server. The
                proxy server intercepts and inspects traffic between a
                client and web server. This is similar to a man-in-the
                middle attack but for positive use. In SSL inspection:
                <ul>
                    <li>
                    The client establishes an SSL tunnel with the proxy
                    server, which then decrypts the SSL session, scans the
                    content, repackages the SSL session, and sends the
                    transmission to the web server via an SSL tunnel.
                    </li>
                    <li>
                    The process is reversed when the web server establishes
                    an SSL tunnel with the proxy server that decrypts,
                    scans, and repackages the SSL session before sending the
                    transmission to the client.
                    </li>
                    <li>
                    The proxy server blocks the transmission of
                    inappropriate or unauthorized content in either
                    direction.
                    </li>
                </ul>
                </li>
            </ul>
            </li>
            <li>Can be used to secure LDAP (LDAPS) and FTP (FTPS).</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Transport Layer Security</td>
        <td>
        Transport Layer Security is the successor to SSL 3.0.
        <ul>
            <li>
            TLS and SSL are similar but not interoperable, although most
            applications can use both SSL and TLS.
            </li>
            <li>
            Applications that can use both SSL and TLS negotiate which
            protocol to use during the handshake process.
            <ul>
                <li>
                An SSL session begins when the client sends a client hello
                message to the server.
                <ul>
                    <li>
                    The client hello message specifies the highest SSL/TLS
                    version that the client supports.
                    </li>
                    <li>
                    The message also contains a random number, a list of
                    ciphers, and suggested compression methods.
                    </li>
                </ul>
                </li>
                <li>
                The server responds with a server hello message.
                <ul>
                    <li>
                    The server hello message specifies the protocol version,
                    a different random number, and the selected cipher and
                    compression method.
                    </li>
                    <li>
                    The server sends a certificate message followed by a
                    server hello done message.
                    </li>
                </ul>
                </li>
                <li>
                The client responds with a client key-exchange message.
                <ul>
                    <li>
                    The random numbers exchanged earlier are used to compute
                    the master secret.
                    </li>
                    <li>
                    All further key data for the connection is derived from
                    the master secret.
                    </li>
                </ul>
                </li>
                <li>
                The client then sends a change cipher spec message which
                indicates that further communication will be encrypted.
                </li>
                <li>
                The client then sends a finished message.
                <ul>
                    <li>The finished message contains a hash and a MAC.</li>
                    <li>
                    The server attempts to decrypt the finished message and
                    verify the hash and MAC.
                    </li>
                    <li>
                    If the server fails to decrypt the message, the
                    connection is ended.
                    </li>
                </ul>
                </li>
                <li>
                If the server succeeds in decrypting the message, the server
                sends the client a change cipher spec message indicating
                that further transmission will be encrypted.
                </li>
                <li>
                The server then sends a finished message to the client.
                <ul>
                    <li>The finished message contains a hash and a MAC.</li>
                    <li>
                    The client attempts to decrypt the finished message and
                    verify the hash and MAC.
                    </li>
                    <li>
                    If the client fails to decrypt the message, the
                    connection is ended.
                    </li>
                    <li>
                    If the client succeeds, the handshake is considered
                    complete.
                    </li>
                </ul>
                </li>
            </ul>
            </li>
            <li>
            Many secure connections that are described as using SSL might
            actually be using TLS instead.
            </li>
            <li>TLS uses Diffie-Hellman or RSA to exchange session keys.</li>
            <li>
            TLS is implemented through two protocols:
            <ul>
                <li>
                TLS Record provides connection security with encryption
                (with DES for example).
                </li>
                <li>
                TLS Handshake provides mutual authentication and choice of
                encryption method.
                </li>
            </ul>
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Secure Shell</td>
        <td>
        SSH allows for secure interactive control of remote systems.
        <ul>
            <li>
            SSH uses RSA public key cryptography for both connection and
            authentication.
            </li>
            <li>
            SSH uses the IDEA algorithm for encryption by default. However,
            it is able to use Blowfish and DES.
            </li>
            <li>SSH is a secure and acceptable alternative to Telnet.</li>
            <li>
            SSH is used by unsecured protocols to establish a secure
            channel. For example, SFTP and SCP are secure file copy
            protocols that use SSH.
            </li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

### HTTPS and S-HTTP

A common unsecured protocol is HyperText Transfer Protocol (HTTP). HTTP is used for exchanging web content and passes data in cleartext. HTTP uses TCP port 80 and is stateless, which means by default it doesn't keep track of clients. To solve this problem, cookies can be used to keep track of the client's behavior. To secure HTTP, use one of the following protocols:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">
        Protocol
        </th>
        <th scope="col" class="fw-bold">Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>HTTPS</td>
        <td>
        HyperText Transfer Protocol Secure is a secure form of HTTP that
        uses either SSL or TLS to encrypt sensitive data before it is
        transmitted. HTTPS:
        <ul>
            <li>
            Is stateful, which means that it keeps track of the client. To
            do this, the client must communicate with the same HTTPS server
            for the duration of the session. Load balancing is not possible
            during the connection and is available only to initially
            determine which server will handle the client's session.
            </li>
            <li>
            Requires TCP port 443 inbound on the web server to be open.
            </li>
            <li>
            Can be identified by verifying that the URL starts with https://
            or by looking for a lock symbol in the browser. Double-clicking
            on the lock icon displays the certificate.
            </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>S-HTTP</td>
        <td>
        Secure HyperText Transfer Protocol (S-HTTP) is an alternate protocol
        that is not widely used because it is not as secure as HTTPS. S-HTTP
        :
        <ul>
            <li>
            Is connectionless, unlike SSL, which is connection oriented.
            </li>
            <li>
            Provides only message security, unlike HTTPS, which provides a
            full secure channel for all messages.
            </li>
            <li>Does not use port 443.</li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

## 10.1.4 Adding SSL to a Website

### Adding SSL to a Website 00:00-00:43

In this demonstration, we'll look at using SSL for a website. We're going to use Windows Server 2019 to configure a website. We're on this client machine in Windows 10 with a browser open.

As you can see, we're using HTTP for this website, so traffic sent between the client and the website is unsecure. To secure communication between the client and the website, we can add SSL to the website. We do this by editing the bindings. The bindings identify the protocols that are used on the website. Currently, we support the HTTP protocol, which uses port 80. To use SSL, we need to add bindings for HTTPS.

### Current Segment Indicator Changing from HTTP to HTTPS 00:43-03:11

We're going to go to the Internet Information Service Manager, so let's switch over to our server. Let's go to Start and Server Manager. In the tools, we'll select IIS Manager. First, we're going to go down to our default website. We can right-click the default website we've created. Go to Edit Bindings. We can see our HTTP port 80 here. We'll click Add.

We can switch this to HTTPS. You can see that it automatically switches to port 443. Notice that secure communications with this website uses port 443 instead of port 80. When using SSL, you must also have a server certificate, or SSL certificate. The certificate identifies the server and validates its identity. In this case, we don't currently have a certificate set up, so we're going to click Cancel and Close. We're going to go to our server, and you go to Server Certificates.

Now, if our website were available on the internet, we would create a certificate request here and send that request to a well known public key infrastructure, or PKI, such as DigiCert. When that request was returned, we would use this complete certificate request option to import the completed certificate onto our server. In this demonstration, we're going to use Create Self-Signed Certificate. The self-signed certificate gives us a certificate that we can use. However, clients won't automatically trust the certificate that we use. We'll see how this works later. We'll enter in a name for the certificate. Let's call it Cert 2019. Click OK.

You can see our certificate here. With this certificate created, we'll go back to our default website, right-click, Edit Bindings > Add > HTTPS. It switches to the 443. HTTP/2 is how semantics flow over TCP connections. Most browsers support HTTP/2, so disabling this may not be needed. OCSP Stapling checks to see if a certificate is revoked and has been an alternative to Certificate Revocation List (CRL) Protocol. We're going to leave both of those unchecked for now. We're going to go down, and we can see our Cert 2019 right here. Select it. Click OK and Close.

### Test HTTPS 03:11-04:28

That certificate's created. Now we can go over to our client machine and test this out. We're back on our Windows 10 client machine. We have our HTTP, so you want to switch this over to HTTPS. All you have to do is put in the S and go.

The first message we get is that there's a problem with the website's security certificate. We started to use HTTPS, but our computer recognizes that the certificate wasn't issued by a trusted certificate authority. In other words, the server has no proof, other than its own words, to verify its identity.

In this case, we know who the server is, so we can continue to the website and accept the certificate. Notice that we're accessing the website. The URL is HTTPS. Let's go ahead and click Continue.

The message told us there was a problem with the certificate, but we're still using HTTPS to connect to the website. In this case, we're giving the user the option of using HTTPS or HTTP when communicating with our server. A more likely example is to require SSL for certain communications.

In this case, we're going to require SSL for the entire website, so a connection won't be granted unless the client and the server are both using SSL. To do this, we're going to go back to our web server, to Internet Information Services Manager.

### Require SSL for Entire Website 04:28-05:48

We're going to click the default website. Go to SSL settings. We're going to tell it to require SSL. We'll check the box and hit Apply to save those changes. Now we can go back to the client.

First, let's try to access the website using just HTTP. We'll just go ahead and take out the S. That's all we have to do. Hit Enter. We get this error that says access is denied. Now let's go ahead and put the S back. Now it's basically denying us unless we're using an SSL certificate with a secure connection. You can see it went ahead and let us back in. The website's requiring SSL.

We were trying to use HTTP, but it won't let us. Now that we're using HTTPS, we can actually access the website because the client and the server are both using SSL at this point. In this example, we've required SSL on the entire website, meaning that any communication to the website must use SSL or be denied. It's likely that you may require SSL only for specific parts of the website.

Today, it's recommended to always use HTTPS with a public-facing website regardless of whether it's a basic website or one used for credit card purchases. Only using HTTP, hackers have easy access to view traffic in plain text.

### Summary 05:48-06:00

And that's it for this demo. We've gone over how to configure SSL on a website using Windows server 2019.

## 10.1.6 IPsec

### IPsec 00:00-00:17

In this lesson, we'll cover Internet Protocol Security, or Ipsec, which is a set of security protocols used to provide authentication and asymmetric encryption for TCP/IP network traffic. It's also used in VPNs.

### OSI Model 00:17-00:56

IPsec operates on top of the Network layer, or Layer 3, of the OSI model. The OSI model provides standards for communication in a computing system, which allows interoperability of various systems regardless of their internal structures. It's composed of seven layers, each layer being served by the layer below it. The bottom three layers are the media layers, and the top four layers are the host layers. Layer 3's primary goal is communication, not security. Applying IPsec on top of Layer 3 provides security to the communication through mutual authentication, integrity, non-repudiation, and confidentiality.

### Authentication Header (AH) 00:56-01:45

The first protocol in the IPsec suite is called Authentication Header, or AH. It encapsulates all the Host layer information, which includes Layers 4 through 7, and replaces it with an authentication header. AH will detect if the IP address on Layer 3 changes through a checksum for all the data from Layers 3 through 7. This provides authenticity and integrity, but not confidentiality because the encapsulated data in the packet is not encrypted. If the packet were intercepted by a sniffer, the data could be read.

AH provides authentication information in the form of a keyed hash, which is based on all the bytes in the packet. AH authenticates packets by digitally signing them, which prevents replay attacks and man-in-the-middle attacks. AH's assigned IP protocol number is 51.

### Encapsulating Security Payload (ESP) 01:45-02:29

The second IPsec protocol option is Encapsulating Security Protocol, or ESP. It's commonly used with IPsec because it provides everything that AH provides plus confidentiality. ESP's assigned IP protocol number is 50.

Like AH, ESP encapsulates the Host layers, 4 through 7, into a new Layer 4 header called an ESP header. Unlike AH, it encrypts the encapsulated data, preventing someone from reading the data if it's sniffed. Also unlike AH, ESP doesn't notice when a lower level IP address changes because there isn't a checksum that includes Layer 3 information. To solve this problem, ESP works best with Network Address Translation, or NAT.

### NAT-T 02:29-03:02

An important consideration is that NAT can have problems with IPsec. Problems can come because IPsec secures the headers of packets and detects if the packets have been tampered with, and NAT needs to tamper with packets by changing source and destination IP addresses and ports.

To fix this, something called NAT Traversal, or NAT-T, was created. NAT-T is designed to allow IPsec to function properly through a NAT device. It does this by encapsulating ESP packets inside a UDP packet and uses UDP port 4500.

### Security Association (SA) 03:02-03:59

Another part of IPsec to consider is the set of specifications that negotiate between nodes to establish the IPsec relationship called a Security Association, or SA. These specifications can include cryptographic keys, authentication preferences, certificates, and algorithm selections.

For example, both endpoints can agree to use the SHA-1 hashing algorithm instead of MD5, AES for symmetric encryption, and RSA for asymmetric encryption. Each tunnel of data uses three different security associations.

First, a management channel is established so that routers or network nodes can exchange security information. Then an outbound security association and an inbound security association are established, each with a unique identifier that's included with each packet sent across the channel. A security association can be established manually or automatically through a protocol called IKE, Internet Key Exchange.

### Internet Key Exchange (IKE) 03:59-04:44

IKE helps establish automatic SAs and a secure tunnel by providing a protected exchange of keys before the full IPsec transmission begins. IKE uses a Diffie-Hellman key exchange to establish a shared session secret. Mutual authentication is provided either by pre-shared keys on both endpoints or through certificates issued by a CA. IKE can also help automate the selection of the best security association for each connection.

For example, if both endpoints support Triple DES and AES for symmetric encryption, then IKE can help them negotiate the strongest security method, AES. Once that's agreed on, they're placed into their SAs. Now their symmetric encryption algorithm is set to encrypt and decrypt data with the IPsec tunnel.

### IPsec Modes 04:44-05:07

Finally, there are two modes that are available to use with IPsec circuits, including VPNs.

The first is called tunnel mode. It's commonly used to provide secure communication between two network gateways. For example, it will allow any user at Corporate Office A to communicate safely with any user at Corporate Office B because both offices have secure gateways acting as IPsec proxies.

### IPSec Modes 05:07-05:16

The second is called transport mode. It's used when two hosts connect directly with each other and the circuit is broken off after the session ends.

### Summary 05:16-06:08

That's it for this lesson. In this lesson, we discussed how IPsec secures IP traffic across the network. Then we looked at elements of the IPsec suite. First, we looked at AHs, or Authentication Headers. Then we looked at ESP, or Encapsulating Security Payload. Remember to use NAT-T to enable ESP to function properly. Next, we discussed how Security Association specifications work. Then we looked at using Internet Key Exchange protocol to implement the SAs. Finally, we covered the two IPsec modes, tunnel mode and transport mode. Tunnel mode allows protected communication between users at both ends of the secure tunnel through their gateways, and transport mode is for direct connection between hosts for a specific session.

## 10.1.7 IPsec Facts

This lesson covers the following topics:

<ul>
   <li>
    IPsec protocols
   </li>
   <li>
    IPsec modes of operation
   </li>
   <li>
    Internet Key Exchange (IKE)
   </li>
   <li>
    IPsec facts
   </li>
  </ul>

### IPsec Protocols

IP security (IPsec) provides secure data transmission over unprotected TCP/IP networks, such as the internet. IPsec operates on OSI Layer 3, or the Network layer. It provides mutual authentication, integrity, non-repudiation, and confidentiality.

![OSI Model](/images/10/osi_model_image.jpg)

IPsec includes two protocols:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">
        Protocol
        </th>
        <th scope="col" class="fw-bold">Function</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Authentication Header (AH)</td>
        <td>
        AH provides authenticity, non-repudiation, and integrity.
        <p>AH:</p>
        <ul>
            <li>
            Does not provide confidentiality because the data in the packet
            is not encrypted.
            </li>
            <li>
            Provides protection against replay and man-in the-middle
            attacks.
            </li>
            <li>
            Uses a keyed hash based on all the bytes in the packet for the
            authentication information.
            </li>
            <li>Authenticates packets by digitally signing them.</li>
            <li>Uses IP Protocol 51.</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>Encapsulating Security Payload (ESP)</td>
        <td>
        ESP provides all the security of AH plus confidentiality.
        <p>ESP:</p>
        <ul>
            <li>Is the most commonly used IPsec protocol.</li>
            <li>Provides data encryption.</li>
            <li>Uses IP Protocol 50.</li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

### IPsec Modes of Operation

Whether you use AH or ESP, there are two modes of operation that can be implemented with IPsec:

<table>
    <thead>
    <tr>
        <th class_="firstTableHeader" scope="col" class="fw-bold">Mode</th>
        <th scope="col" class="fw-bold">Function</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Transport mode</td>
        <td>Encrypts only the payload (data).</td>
    </tr>
    <tr>
        <td>Tunnel mode</td>
        <td>
        Encrypts the entire packet. Both the data inside the packet and the
        IP headers are encrypted. The entire packet is encapsulated in a new
        packet.
        </td>
    </tr>
    </tbody>
</table>

### Internet Key Exchange (IKE)

A Security Association (SA) is the establishment of shared security information between two network entities to support secure communications. An SA may include algorithm selection, cryptographic keys, and/or digital certificates. A security association can be established manually or automatically through a protocol called Internet Key Exchange (IKE). IKE helps to establish automatic Security Association.

IKE:

<ul>
   <li>
    Helps the two endpoints set up a secure tunnel by providing a secure exchange of shared keys before a full IPsec
    transmission begins.
   </li>
   <li>
    Uses a Diffie-Hellman key exchange to set up a shared session secret from which cryptographic keys are derived.
   </li>
   <li>
    Uses mutual authentication that is provided by either pre-shared keys on both endpoints or certificates issued by a
    CA.
   </li>
   <li>
    Can be implemented to automate the selection of the best security association for each connection.
   </li>
   <li>
    Uses UDP port 500.
   </li>
</ul>

### IPsec Facts

Be aware of the following:

<ul>
   <li>
    IPsec is included in Windows Firewall with Advanced Security and is named Connection Security Rules.
   </li>
   <li>
    Network Address Translation (NAT) can cause communication errors with an IPsec VPN tunnel because it makes changes to IP headers, such as changing source and destination IP addresses and ports. NAT-Traversal (NAT-T) is a new method designed to
    allow IPsec to function properly through a NAT device.
   </li>
   <li>
    IPsec tunnels are established in two phases, which are main mode and quick mode.
   </li>
   <li>
    IPsec is most commonly used with L2TP VPNs.
   </li>
</ul>

## 10.1.8 Requiring IPsec for Communications

### Require IPsec for Communications 00:00-00:32

In this demonstration, we'll look at requiring IPsec for communications between two network hosts. We'll use a Windows server and a Windows workstation.

To secure communications with IPsec, we ‘ll use the Windows Defender Firewall with Advanced Security. Let's search for Windows Defender Firewall.

There it is. Let's expand this. You'll notice that no rules are defined in the connection security rules here, so we need to define a new rule.

### Define Rules 00:32-01:12

To define a new rule, you right-click Security connection rules and Create a new rule. The wizard displays.

First, we choose the type of rule to use for IPsec. We have several options. We could configure an isolation rule, which restricts connections based on authentication criteria such as domain membership or health status.

We have an authentication exemption. It will prevent authenticated connections with specific computers. In other words, it exempts computers from connecting.

We have server to server rules. These authenticate connections between specified computers. Tunnel rules authenticate connections between two computers; it creates a tunnel between the two.

We also can create custom rules.

### Create an Isolation Rule 01:12-02:41

We want to set up an isolation rule. We'll select isolation. Click Next. Now we need to specify how to enforce authentication. You can either request to use IPsec or require the use of IPsec.

If you request, the default option is the computer attempts to use IPsec. If either computer in the communication channel can't use IPsec, then it fails over to unsecured communications

Notice that this rule is applied to both inbound and outbound connections. If this rule is not secure enough, then you can increase security by requiring IPSec for inbound and outbound connections.

When you require IPSec, both computers in the communication must use IPsec, otherwise communications are not allowed.

However, there is a middle option that tries to strike a balance between the other two options. It requires authentication for inbound connections. In other words, if a computer is establishing a connection with the system, authentication is required; when the system establishes an outbound connection with another computer, authentication is requested.

When you choose this option, IPsec is used for outbound communication if both computers can use IPsec. If they can't, outbound communications are unsecured.

We'll request authentication for inbound and outbound connections. Click Next. That's the default option. Now, we determine the type of authentication method we want to use.

### Select Authentication Method 02:41-03:42

The first option, the default, is to use whatever authentication methods are specified in the default IPsec settings. Most of the time, you'll use computer-based Kerberos. In order to use Kerberos, both computers must be in the same active directory forest.

You also have the option to specify computer and user Kerberos. Choosing this option also requires both computers to be in the same active directory forest. The systems must be re-authenticate using user authentication as well.

In this demo, we'll use computer authentication. There's also an advanced option. After you select Advanced, click Customize. Customize allows you to set up multiple authentication methods.

If the first method we set up fails, the system defaults to the next available authentication type. On the left, we specify the first authentication method. If we click Add, the options are a computer using Kerberos, a computer using NTLM, or a certificate from a trusted certificate authority.

### Set up Certificates 03:42-04:34

That last option is useful if both computers are not in the same active directory forest. In this case, we can use certificates to authenticate both ends of the communication channel.

We'll configure both computers to trust the issuing CA of the certificates used on the computers. We browse through to select the certificates that we want to use.

We also have the option of using a pre-shared key that would be used by both computers. It's noted here that this is not recommended. A pre-shared key is the least secure option of these four. Let's go ahead and click Cancel.

On the left, we specify the first authentication method. If the authentication doesn't work, the system would use the second authentication method we configured here on the right. For this demo, both hosts are members of the same domain, so we'll use computer-based Kerberos authentication. Now we'll click Next.

### Specify Network Location Profile 04:34-05:27

Now we can specify the network location profile to which this rule will be applied.

Because we have a desktop workstation and a server that are members of the same domain and they will always be attached to the same network, we can select domain.

However, if you have a roaming computer such as a laptop, notebook, or something of that sort, then this becomes a little more of an issue.

While at work, the notebook or laptop would be using the domain profile. When the computer is used from home or another location, it would use a public or private profile on the system, depending on where we're connecting.

For our purposes today, we'll use all three of these profiles. We could turn one or more of them off if we wanted to restrict that.

Now we need to name this rule. We'll enter ‘Request IPsec policy'. Click Finish. At this point the rule has been configured, but we've configured only one half of the communication channel.

### Configure Workstation Rule 05:27-06:08

We'll go to the workstation side and configure the same rule here. On the workstation side, we'll go to the Search box and type Windows Defender Firewall with Advanced Security.

We'll go to Connection security rules and right-click. We'll configure this IPsec rule the same way we did on the server system.

Click Isolation. Click Next. Now we'll click Request authentication for inbound and outbound connections. We'll go to Computer Kerberos and leave all three. We'll name it ‘Request IPsec' and click Finish.

### Initiate Communications 06:08-06:49

From the workstation, let's initiate communications between these two computers. We go back to the Search box and open a command prompt.

We'll ping the IP address of the server system. If we don't know the IP address of the server system, we can go over to the server system, open the command prompt, and run ipconfig.

You can see the server address here, 10.0.0.112. Back to our workstation, ping 10.0.0.112. We want this to be a continuous ping so we will cancel and restart it with the -t flag to continuously send pings.

### Monitor Connection 06:49-09:04

You can see we're getting replies from that address. That's perfect.

We've established that we can ping the server. The pinging process will keep going and we'll be able to monitor the connection between the two computers.

We can see the replies from the server and it just keeps running. Now, let's switch back over to the server and go back to Windows Defender Firewall with Advanced Security. We can see the connection rule. Let's go to the Monitoring tab so we can monitor the connection.

If we go to Connection security rule, we can see that the requested IPsec rule is currently in progress. We'll go to Security associations. Here we can look inside the main mode or quick mode and see the connections between our Windows 10 machine and server.

We see information that the connection is working. There are two modes: the main mode and quick mode, because IPsec tunnels are built in two different phases.

Phase one, here, is called main mode; quick mode is here. Phase two is quick mode. Breaking the monitoring information into these two modes is useful. It allows you to troubleshoot each phase of the connection establishment process.

Here in main mode, we see information about the connection. We have the two endpoints here. We can see that this address here is the Windows Server. This is the workstation address here and the remote address.

We can also see that we're using Kerberos authentication here. We're not requiring a second authentication at the moment. If we scroll over or we look at this side, we can see the encryption in the data integrity mode.

We're here, and key exchange is set to none.

Let's right-click and go to Properties. We can see a little more information about the connection. Let's click Cancel. We can do the same thing for the quick mode and see the same information.

Again, we can see both ends of the communications. A local address and a remote address. We can see that AH and ESP are components of quick mode. Now, before we leave Windows Defender Firewall with Advanced Security, we want to show you the global settings.

Recall earlier when we set up our rule? We right-clicked Connection security rules. There, we clicked New rule, Request authentication, and then Authentication method. The default is to use the authentication method specified in IPsec settings.

### Configure IPsec Settings in the Firewall 09:04-09:53

Now we can configure IPsec settings in the Windows Firewall with Advanced Security. That way we don't have to manually configure these settings each time we set up a rule.

We can use the default option. Let's select Cancel. Now, we'll go to Windows Defender Firewall with Advanced Security, right-click, go to Properties, and then we'll go to the IPsec tab.

Here, we configure the IPsec setting defaults. These are the settings applied unless you override them manually when you create the rules. Let's click customize. We can configure how the key exchange works.

If we select Advanced, then we select customize and specify the security methods used. We can enter a specific algorithm to use or we can specify key lifetimes.

These are settings for main mode; data protection is for quick mode.

### Configure Advanced settings 09:53-10:34

If we click Advanced on data protection from quick mode and click Customize on this screen, we can configure the AH and ESP algorithms for data integrity and encryption.

Note that we have the algorithm listed first or the algorithm that is used first. Remember that integrity ensures that the data has not been tampered with in transit; that's hashing.

Encryption encrypts the data so that it can't be sniffed and read. Let's click Cancel. We can configure the default authentication method.

We can set that to computer Kerberos if we want. We used that when we set up the rule. Let's click Cancel, because we don't want to set these defaults right now. Click Cancel again.

### Review Tools 10:34-11:13

The last thing we need to review are the tools you can use to manage IPsec communications from the command line.

Let's go to the command prompt. We'll type 'netsh advfirewall' and ‘?'. It displays the commands we have available. We'll use the consec command. Let's press Up and run the consec command.

Here you see the commands available within this context. We can add a new connection, delete all matching connection security rules, display the configuration script, display a list of commands, set new values for properties of an existing rule, and display a specified connection security rule.

### Summary 11:13-11:57

That's it for this demonstration. In this demonstration, we used IPsec to secure communications between two network hosts. We used Windows Firewall with Advanced Security to set up connection security rules on both sides of the communication.

We set up secured communications between a Windows server system and a Windows client system. We then used the ping command to establish communications between the two hosts. We monitored the connection to verify that IPsec was being used to secure the communications between them. We then talked about configuring the IPsec defaults.

We ended this demonstration by talking about how you can manage IPsec rules from the command line.
